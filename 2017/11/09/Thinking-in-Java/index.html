<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title> Thinking in Java · swanf </title>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="swanf">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />
<meta name="keywords" content="nlvi, Nlvi" />

    <link rel="apple-touch-icon"  sizes="72x72"  href="assets/timg.ico">
    <link rel="apple-touch-icon-precomposed"  sizes="72x72"  href="assets/timg.ico">


    <meta name="subtitle" content="电池已有足够电量。">


    <meta name="description" content="java/web养成中">



    <meta name="keywords" content="java, Nlvi" />

<link rel="stylesheet" href="/swanf/style/style.css">
<script src="/swanf/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "swanf",
        author: "swanf",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/swanf/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/swanf/syuanpi/syuanpi.min.css">




    <link rel="icon" href="assets/timg.ico">







</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/swanf/tags/java/" style="font-size: 14px;">java</a> <a href="/swanf/tags/misc/" style="font-size: 14px;">misc</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">swanf</a></span>
                
                    <span id="subtitle">电池已有足够电量。</span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        <li class="menu-item">
            <a href="javascript:;" id="search">
                <span>搜索</span>
                
                    <span class="menu-item-label">search</span>
                
            </a>
        </li>
        
        
        
            <li class="menu-item">
                <a href="/swanf/">
                    <span>文章</span>
                    
                        <span class="menu-item-label">article</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/swanf/archives">
                    <span>归档</span>
                    
                        <span class="menu-item-label">archives</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>标签</span>
                    
                        <span class="menu-item-label">tags</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/swanf/about">
                    <span>关于</span>
                    
                        <span class="menu-item-label">about</span>
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
</header>
<div class="mobile-header">
    <div class="mobile-header-body">
        <div class="mobile-header-list">
            
            
                <div class="mobile-nav-item">
                    <a href="/swanf/">
                        <span>文章</span>
                        
                            <span class="menu-item-label">article</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/swanf/archives">
                        <span>归档</span>
                        
                            <span class="menu-item-label">archives</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item inner-cloud">
                    <div class="mobile-nav-tag">
                        <a href="javascript:;" id="mobile-tags">
                            <span>标签</span>
                            
                                <span class="menu-item-label">tags</span>
                            
                        </a>
                    </div>
                    <div class="mobile-nav-tagcloud">
                        <div class="mobile-tagcloud-inner">
                            <a href="/swanf/tags/java/" style="font-size: 14px;">java</a> <a href="/swanf/tags/misc/" style="font-size: 14px;">misc</a>
                        </div>
                    </div>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/swanf/about">
                        <span>关于</span>
                        
                            <span class="menu-item-label">about</span>
                        
                    </a>
                </div>
            
            
        </div>
    </div>
    <div class="mobile-header-nav">
        <div class="mobile-header-item" id="mobile-left">
            <div class="header-menu-item">
                <span class="header-menu-line"></span>
            </div>
        </div>
        <h1 class="mobile-header-title">
            <a href="/">swanf</a>
        </h1>
        <div class="mobile-header-item"></div>
    </div>
</div>

    <div class="container">
        <main class="main" id="main">
            
    
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年11月9日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                Thinking in Java
            
            </h1>
            
                
                    <div class="post-tags syuanpi riseIn-light back-3">
                    
                        <a href="/swanf/tags/java/">java</a>
                    
                    </div>
                
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                <p><img src="assets/tij.jpg" alt="thinking-in-java4"></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>策略process</li>
<li>装饰器decorator</li>
</ul>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h2><p>访问控制具体关注的是client和library creator之间的一种沟通communication</p>
<ol>
<li>一个java文件里面只能有一个public的class</li>
<li>.java文件编译之后后缀变成了.class，这就是一个可以工作的程序了。可以通过jar archiver打包变成<br>JAR执行。和普通文件编译直接变成可执行文件或库library不一样。</li>
<li>这些乱七八糟的.java和.class通过package关键字笼络在一起，就像是一把伞把他们裹起<br>来了。</li>
<li>所谓import其实就相当于将一个package引进来了。这两个关键字作用都是为了防止撞名name<br>clashing。<a id="more"></a></li>
<li>package必须是非注释代码的第一行。</li>
<li>包的停用，如果出现目录中找不到类而它却明明在里面的信息，试着注释掉package语句</li>
</ol>
<h2 id="包的访问符"><a href="#包的访问符" class="headerlink" title="包的访问符"></a>包的访问符</h2><p>package access = 默认的；只能包package内访问，所谓“包访问”权限</p>
<h2 id="继承的儿子能访问的权限"><a href="#继承的儿子能访问的权限" class="headerlink" title="继承的儿子能访问的权限"></a>继承的儿子能访问的权限</h2><p>protected/public，package access也是可以的，只要在同包</p>
<ul>
<li>对于没有直接指明package的，java都看作是default package的目录下的class。因此同一父目录的<br>两个类，class可以创建另外一个不同的class的实例。</li>
</ul>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>只能在自己类中的方法可以用。在多线程中很有用。</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>只能给自己的子类用。就是为了联系父子类之间的权限。</p>
<h2 id="对于封装"><a href="#对于封装" class="headerlink" title="对于封装"></a>对于封装</h2><p>使用access control出于两方面原因，一是用接口明确client的边界，能用什么不能用什么，二是为了让接口分离出来，改变内部结构（非public的）不会影响接口（public）的使用。</p>
<h1 id="类的重用"><a href="#类的重用" class="headerlink" title="类的重用"></a>类的重用</h1><p>包括类中创建它类实例（composition）和新建类作为旧类的一个“类型”（inheritance）</p>
<ul>
<li>Object1 + “String”：由于只有String对象才能够加上String，那么这里将会自动调用我们Object1的toString()方法。即使对于primitive类型也是生效的。</li>
</ul>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>子类将会自动调用父类的构造函数，也就是说，形成子类是一个“从外到里”的初始化过程——先生成最外层的父类，按照继承关系从大到小生成实例，直到这个子类的构造函数。</p>
<h2 id="父类中没有无参构造函数"><a href="#父类中没有无参构造函数" class="headerlink" title="父类中没有无参构造函数"></a>父类中没有无参构造函数</h2><p>那么子类中的默认构造无参函数就不会存在，因为子类中的默认无参函数会默认调用父类中无参再调用子类中的无参——所谓的“从外到里”初始化过程。</p>
<h2 id="代表"><a href="#代表" class="headerlink" title="代表"></a>代表</h2><p>一个介乎composition和inheritance的用法：代表团delegation。具体作用有点类似实现一个接口。但是它并不需要关键字，只需要在新类创建一个旧类的实例，用“.”访问这个实例里面的各种方法。这种的话在调用库的时候还蛮常见的，例如Math.abs()。</p>
<ul>
<li>注：delegate可以通过IDEA的generate自动生成。</li>
</ul>
<h2 id="清除工作"><a href="#清除工作" class="headerlink" title="清除工作"></a>清除工作</h2><p>是指将非内存的东西恢复回对象存在之前的景象。</p>
<ul>
<li>一般情况下，cleanup工作交给GC(Garbage Collector)去做，但如果必须自己明确清除，就必须知道垃圾收集的顺序、自己的清除方法（不要依赖finalize()）。</li>
</ul>
<h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>在想要利用新类的特性而不用新类的接口时，用合成composition。想创建一个已存在的类的特殊版本时，用继承inherit。</p>
<h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h2><p>符合has-a用合成，符合is-a用继承。（通常问自己一个问题就心中有数了，Do I need to upcast? 是的话，就用继承！）</p>
<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>可以直接用public关键字（这样就可以直接用<code>.</code>调用类中的方法，显得更加清晰易懂），但这只是特殊情况，一般来说你应该用private的。——这种情况下，protected就有用了（它同时也包含了package access的范畴）。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>不能够被改变。&gt; this cannot be changed。For 2 reasons: design or efficiency</p>
<ul>
<li>final可以加在方法的参数里，说明这个参数只能被读取，不能被更改。</li>
</ul>
<h2 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h2><p>能说明这个primitive是一个compile-time值，它不会随着时间的改变而变化。在内存中一直占据同一个位置。而只有final只是说明它是一个不能够被重新赋值的值，但是每次new它所在类的时候都会被重新初始化（加了static只能被初始化一次）。</p>
<h2 id="以前的"><a href="#以前的" class="headerlink" title="以前的"></a>以前的</h2><p>Vector 和 Hashtable 被现代java的 ArrayList 和 HashMap 替代啦～</p>
<h1 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h1><h1 id="“反射”"><a href="#“反射”" class="headerlink" title="“反射”"></a>“反射”</h1><h2 id="万事万物皆对象"><a href="#万事万物皆对象" class="headerlink" title="万事万物皆对象"></a>万事万物皆对象</h2><p>所以说，类也是一个对象，它是java.util.Class的实例对象</p>
<h2 id="实例对象的表示"><a href="#实例对象的表示" class="headerlink" title="实例对象的表示"></a>实例对象的表示</h2><p>有三种方法：<br><code>myClass c = new myClass();</code> <em>c是myClass的实例对象</em><br>1.<code>Class c1 = myClass.class;</code> <em>c1、c2是Class类的实例对象，是myClass类的类类型（class type），有点元实例对象的感觉</em></p>
<ol>
<li><blockquote>
<p>Class c2 = c1.getClass();</p>
</blockquote>
</li>
<li><blockquote>
<p>Class c3 = null;<br>c3 = Class.forName(“类的全称”);</p>
</blockquote>
</li>
</ol>
<h2 id="实例创建"><a href="#实例创建" class="headerlink" title="实例创建"></a>实例创建</h2><p>可以通过一个类的类类型创建一个这个类的实例，通过.newInstance()方法。要求这个类有无参数的构造方法才行（默认那个无参可以）。</p>
<ul>
<li>.class，可以看作是编译出来之后的字节码（也是.class后缀）</li>
</ul>
<h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><ol>
<li>Class.forName(“”)不仅表示了类类型，还代表了”动态加载类”。区分好编译和运行。编译时加载的是静态加载类，运行时加载的是动态加载类。</li>
<li>功能性的类，尽量使用动态加载<ol>
<li>new 出来的对象是”静态加载类”，在编译时刻就需要加载所有可能用到的类。就是说一个类加载不成，程序就会报错，整个垮掉。</li>
<li>而用Class.forName()编译的时候完全没问题的，不会管你的类错不错。可以在运行时再加载，运行到加载出错之前的都能顺利使用。</li>
<li>Class c1 = double.class; <em>double这个数据类型的类类型<br></em>  Class c2 = Double.class; <em>Double这个封装类的类类型  Class c3 = void.class;</em></li>
</ol>
</li>
</ol>
<h3 id="Method方法类"><a href="#Method方法类" class="headerlink" title="Method方法类"></a>Method方法类</h3><ul>
<li>Method类，方法对象，一个成员方法就是一个Method对象</li>
<li>.getMethods()方法获取的是所有public函数，包括父类继承而来的</li>
<li>.getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</li>
<li>.getReturnType()得到该方法的返回值类型的类类型</li>
<li>.getParameterTypes()获得参数列表类型的类类型</li>
</ul>
<h3 id="Field成员变量类"><a href="#Field成员变量类" class="headerlink" title="Field成员变量类"></a>Field成员变量类</h3><ul>
<li>成员变量也是对象，是java.lang.reflect.Field的对象</li>
<li>Field[] fs = c.getFields()方法获取所有public的成员变量Field[]信息</li>
<li>c.getDeclaredFields获取的是该类自己声明的成员变量信息</li>
<li>field.getType()获得成员类型的类类型</li>
<li>field.getName()得到这个成员比变量的名字</li>
</ul>
<h3 id="Constructor构造函数类"><a href="#Constructor构造函数类" class="headerlink" title="Constructor构造函数类"></a>Constructor构造函数类</h3><ul>
<li>通过Class.getConstructor()获得Constructor[]所有公有构造方法信息</li>
<li>建议getDeclaredConstructors()获取自己声明的构造方法</li>
<li>Constructor.getName():String 得到构造函数的名字</li>
<li>Constructor.getParameterTypes():Class[] 得到参数列表的类类型</li>
<li>总之，得到一个类的类类型(Tpye)，它的相关信息就很容易得到啦。</li>
</ul>
<h2 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h2><ol>
<li>通过反射可以调用类的方法，哪怕是private的方法，从而修改一些默认的行为。</li>
<li>方法的名称和方法的参数列表唯一决定一个方法。</li>
<li>method.invoke(对象,参数列表)<ol>
<li><blockquote>
<p>A a = new A();<br>Class c = a.getClass();<br>要获取一个方法，首先要获取一个类类型。</p>
</blockquote>
</li>
<li><blockquote>
<p>Method method = c.getMethod(“方法名”,形参.class…);<br>用上类类型，通过名称和参数来获取方法（参数以类类型的方式传进去）<br>（…表示不止一个），也可以new Class[]{…}传参数</p>
</blockquote>
</li>
<li><blockquote>
<p>Object o = method.invoke(“a”,实参…);</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<ul>
<li>使用invoke反向调用（平时都是a.print()的，现在反过来用了）</li>
<li>方法如果没有返回值返回null，如果有返回值返回具体值，参数可用数组的方式表示，也可以直接列举，没有参数就不写</li>
</ul>
<ol>
<li>泛型的本质<ul>
<li>反射的操作都是在”编译之后”的操作，编译之后的集合的泛型是去泛型化的——Java中集合的泛型是骗人的。只是为了防止错误输入，只在编译阶段有效。绕过编译就无效了。</li>
<li>验证：绕过编译，通过方法的反射来操作。 <blockquote>
<p>ArrayList<string> arr2 = new ArrayList&lt;&gt;();<br><br>Class c2 = arr2.getClass();<br><br>Method method = c2.getMethod(“add”, Object.class);<br><br>method.invoke(arr2, 33);</string></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="“正则表达式”"><a href="#“正则表达式”" class="headerlink" title="“正则表达式”"></a>“正则表达式”</h2><ol>
<li><p>“\ “：</p>
<ul>
<li>其他语言中，\表示“插入一个普通的反斜杠，不要给它任何特殊意义”，而\在java中表示“我要插入一个正则表达式的反斜线，所以其后的字符具有特殊意义”。<br><br><strong>“2个正则反斜杠等于其他语言中的1个正常反斜杠。”</strong></li>
<li>一些反斜杠相关的表示方式：<blockquote>
<p><code>\\\\</code> <em>普通的反斜线</em> …<code>\\d</code>表示数字… <code>\\D</code>非数字字符(大写表取非)…<code>\\w</code>单词字符…<code>\\W</code>非单词字符<br><code>\\s</code>空白符…<code>\\S</code>非空白符…<code>\\b</code>词的边界，放的位置和行边界^$一样，最前或最后…<code>\\B</code>非词的边界</p>
</blockquote>
</li>
</ul>
</li>
<li><p>有特殊含义的保留字符：</p>
<ul>
<li><p>如果要剥除保留字符的特殊含义，把它当做普通字符看待，要加\，正则表达式的反斜线哟～</p>
<blockquote>
<p><code>?</code> 可能，有或没有{0,1}…<code>+</code> ≥1个之前的表达式{1,}…<code>*</code>0个或多个{0,}…<code>.</code>任意字符…<br><code>.*</code>0个或多个任意字符（十分常用）…<code>.+?</code>可能没有字符，可能1个或多个任意字符…</p>
</blockquote>
</li>
<li><p>边界有关的（注意字符的位置！    ^在字符前，$字符后）：<code>^a</code> a开头，<code>b$</code> b结尾…</p>
<blockquote>
<p><code>-?\\d+</code>    “可能有1个负号，后面跟着one plus位数字<br><br><code>(-|\\+)?\\d+</code>    “有符号或无符号，后面跟着one plus位数字”</p>
</blockquote>
</li>
</ul>
</li>
<li><p>量词</p>
</li>
</ol>
<ul>
<li><p><em>贪婪、勉强(贪婪的加上?)、占有(只java可用，贪婪的加上+)</em></p>
<ol>
<li><p>贪婪型：最大匹配。    X?、X*、X+、X{n}</p>
<ul>
<li>会尽量大范围的匹配，直到匹配了整个内容，这时发现匹配不能成功时，开始回退缩小匹配范围，直到匹配成功。</li>
<li>用<code>&lt;.+&gt;</code>去匹配 <code>cc&lt;tr&gt;aa&lt;/tr&gt;bb</code>，会得到<code>&lt;tr&gt;aa&lt;/tr&gt;</code>这一大串，因为它是最大范围的两个。</li>
<li>我们匹配的时候应该看最后面能匹配到哪</li>
</ul>
</li>
<li><p>勉强型：最小匹配。    X??、X*?、X+?、X{n}</p>
<ul>
<li>只要匹配成功，就不再继续尝试匹配更大范围的内容</li>
<li>用<code>&lt;.+?&gt;</code>去匹配 <code>cc&lt;tr&gt;aa&lt;/tr&gt;bb</code>，会得到<code>&lt;tr&gt;和&lt;/tr&gt;</code>这两串。</li>
<li><code>.+?</code> 匹配一个字符后，马上试一试<code>&gt;</code>的匹配可能，失败了，则<code>.+?</code> 匹配下一个字符，再马上试一试<code>&gt;</code>的匹配可能</li>
</ul>
</li>
<li><p>占有型：完全匹配（最严格，必须一模一样才匹配！）    X?+、X*+、X++、X{n}</p>
<ul>
<li>占有型可以防止回溯。与贪婪型有一定的相似性，那就是都尽量匹配最大范围的内容，直到内容结束，但与贪婪型不同的是，完全匹配不再回退尝试匹配更小的范围。</li>
<li>它不由原路返回。也就是说，一口匹配，搞不定就算了。够干脆。<em>感觉跟直接自己手打一次的正则没差别啊…</em></li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>String类的相关方法</p>
<ul>
<li><code>&quot;待检测字符串&quot;.matches(&quot;正则表达式&quot;);</code>    boolean，可用于判断是否满足表达式   </li>
<li><code>&quot;待切分字符串&quot;.split(&quot;正则表达式&quot;);</code>    String[]，可用于将长字符串按特定的regex切分</li>
<li><code>&quot;待取代字符串&quot;.replaceFirst(&quot;正则表达式&quot;,&quot;转换成什么&quot;);</code> String，用于替换字符</li>
<li><em>如果不是只是用一次的话，非String对象的正则表达式具有更佳的性能。</em></li>
</ul>
</li>
<li><p>正则表达式对象</p>
<ul>
<li><p>Pattern表示编译后的正则表达式，Matcher可以用来调用各种不同的方法来分析具体的匹配情况</p>
<blockquote>
<p>Pattern p = Pattern.compile(“regex”);<br><br>Matcher m = p.matcher(“待检测字符串”);</p>
</blockquote>
</li>
<li><p>Pattern和Metcher具体方法：</p>
<ul>
<li><code>p.split(CharSequence s, int limit)</code>    以p作为分割表达式，返回一个String[]，并且这个字符串数组的length不能大于limit</li>
<li><code>p.matcher(String)</code>    返回一个Matcher对象。</li>
<li><code>p.flag()</code>    返回模式标记值。</li>
<li><code>m.matches(String)</code>    判断是否匹配</li>
<li><code>m.lookingAt()</code>    刚开始那第一部分能否匹配，boolean。</li>
<li><code>m.find()</code>    可在CharSequence中找多个匹配，返回是否匹配，boolean。</li>
<li>`！无论用lookingAt还是find，进行过一次查找后，都将自动进入下一条匹配信息。</li>
<li><code>m.group()</code>    返回前一次匹配操作的整个匹配（第0组group），已匹配部分。</li>
<li><code>find()</code>可以在输入的”任意位置”定位正则表达式，而matches/lookingAt只有在正则从头开始匹配才可能成功。</li>
</ul>
</li>
<li><p>组groups是用括号划分的正则表达式，可以根据组的编号来引用某个组。<br></p>
<ul>
<li><code>(A)((B)(C))</code>中，0组是ABC，1组是A和BC，2组是B和C。</li>
<li><code>matcher.group()</code>可以返回前一次匹配的操作，加上0,1,2可以得到不同的组的输出</li>
<li><code>(?m)</code>表示模式标记，能够显示告诉正则表达式注意输入序列中的换行符</li>
</ul>
</li>
<li><p>Pattern模式标记：</p>
<ul>
<li>标记参数：int flag，可作为<code>Pattern.compile(,)</code>的第二项参数，也可以并入正则表达式</li>
<li><code>Pattern.CASE_INSENSITIVE(?i)</code>    忽略大小写</li>
<li><code>Pattern.MULTILINE(?m)</code>        将字符串中换行符看做一行的末尾</li>
<li><code>Pattern.COMMENTS(?x)</code>        忽略空格、#注释</li>
<li><code>Pattern.DOTALL(?s)</code>        表达式”.”匹配所有的字符，包括行终结符$（默认不匹配）</li>
<li>使用时直接将标记加到正则表达式中，如<code>(?i)l.*?e</code>，表示想要l开头e结尾的单词，且不分大小写</li>
<li>还可以用多个模式标记，中间用”|”隔开，如：<code>Pattern.compile(&quot;l.*?e&quot; , Pattern.CASE_INSENSITIVE|Pattern.MULTILINE)</code>;<br>或者写在正则里面：<code>(?i)(?m)l.*?e</code>，后面不加模式标记参数。</li>
</ul>
</li>
<li><p>替换操作</p>
<ul>
<li><code>str.replaceFirst(String)</code>    替换掉第一个匹配成功的部分</li>
<li><code>str.replaceAll(String)</code>    替换掉所有匹配成功的部分</li>
<li><code>m.appendReplacement(StringBuffer,String)</code>    先将当前匹配子串（当前的m匹配成功）替换为指定字符串（第二个参数），并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里</li>
<li><code>m.appendTail(StringBuffer)</code> 方法则将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="“IO流”"><a href="#“IO流”" class="headerlink" title="“IO流”"></a>“IO流”</h2><ol>
<li><p>File类<br> <br><em>更适合叫“FilePath”</em></p>
<ul>
<li>既表示一个特定文件的目录的名称(name)，也代表一个文件的目录下的所有文件的目录的名称(names)</li>
<li>方法：<code>list()</code>、<code>listFiles()</code></li>
<li>以上两个方法类似，都是得出一个String[]/File[]保存目录下的names，加入参数可挑选特定names</li>
</ul>
</li>
<li><p>FilenameFilter接口，可以作为参数传入以上两个方法。<br> <br><em>策略模式的用法</em></p>
<ul>
<li><p>利用的是FilenameFilter中的accept方法，因此list可以回调（callback）accept去决定文件名是否应该被包括到list中</p>
</li>
<li><p>accept必须传入一个File用来指代在哪个目录下挑选names，以及一个String保存目录下某个文件的名字name。</p>
</li>
<li>因此accept会对names逐一使用，看看是否匹配。</li>
<li>注：FilenameFilter可作为匿名内部类用，但传入的参数必须是final的，这样才能在内部类中使用。</li>
</ul>
</li>
<li><p>（输入输出）流<br> <br><em>流 = 任何有能力（产出/接受）数据的（数据源/接收端）对象</em></p>
<ul>
<li>InputStream/Reader派生（输入）：都有read方法，用于读取单个字节/字节数组</li>
<li>OutputStream/Writer派生（输出）：都有write方法，用于写单个字节/字节数组</li>
<li>但是通常不会用以上的方法，用它们是因为别的类可以用它们，提供更有用的接口。</li>
<li>通常使用流对象都是叠合多个对象来提供所期望的功能。</li>
</ul>
<ol>
<li><p>来源InputStream：表示那些从不同的数据源产生输入的类<br> <br><em>字节数组、String对象、文件、管道、其他种类的流组成的流序列、其他数据源(Internet)</em></p>
<ul>
<li><code>ByteArray\</code>    允许将内存的缓冲区当做InputStream使用</li>
<li><code>StringBuffer\</code>    将String转换成InputStream <strong>[已！弃！用！]</strong></li>
<li><code>File\</code>        从文件中读取信息</li>
<li><code>Piped\</code>        写入相关PipedOutputStream的数据，实现“管道化”，作为多线程数据源</li>
<li><code>Sequence\</code>    将2+个InputStream对象转换为单一InputStream</li>
<li><code>Filter</code> + InputStream    抽象类，作为装饰器为其他InputStream提供服务</li>
<li>方法：<code>available()</code>    没有阻塞的情况下所能读取的字节数。对于文件意味着整个文件（可以用来得到文件的大小），对于不同类型的流就要谨慎了。</li>
</ul>
</li>
<li><p>去处OutputStream：指定了输出所要去往的目标<br> <br><em>字节数组（注意不是String）、文件、管道</em></p>
<ul>
<li><code>ByteArray\</code>    在内存中创建缓冲区。所有送往“流”的数据都要放在次缓冲区</li>
<li><code>File\</code>        将信息写至文件</li>
<li><code>Piped\</code>        任何写入其中的信息都会作为相关PipedInputStream的输出，指定用于多线程的数据的目的地</li>
<li><p><code>Filter</code> + OutputStream    抽象类，装饰器。</p>
</li>
<li><p><em>java中I/O类库不便在于：我们必须创建许多类，“核心”I/O类型加上所有的装饰器，才能得到所需的单个I/O对象</em></p>
</li>
</ul>
</li>
<li><p>Filter\</p>
<ul>
<li><p>\InputStream：</p>
<ol>
<li>通过数据“流”将基本类型的数据从一个地方（out）迁移到另一个地方（in）<br><br><code>DataInputStream</code>    读取不同的基本类型数据以及String对象（所有的方法以read开头）</li>
<li>内部修改InputStream的行为方式：是否缓冲、保留读过的行、把单一字符推回输入流<br><br><code>BufferedInputStream</code>    使用缓冲区（显著提高I/O操作的性能），防止每次读取都得进行实际写的操作<br><em><code>LineNumberInputStream</code>    跟踪输入流中的行号<br><br><code>PushBackInputStream</code>    能弹出最后一个字节——最后这俩一般编程不会用到</em></li>
</ol>
</li>
<li><p>\OutputStream：</p>
<ol>
<li><code>DataOutputStream</code>    将各种基本数据类型以及String对象格式化输出到流中</li>
<li><code>BufferedOutputStream</code>    使用缓冲区，避免每次发送信息都要进行实际的写操作</li>
<li><code>PrintStream</code>    没有Out！产生格式化的打印输出。Data\处理储存，Print\处理显示</li>
</ol>
<ul>
<li>记住”DBP”：这三个是经典的装饰器filter，凡是不是Data/Buffered/Print的，一律都为基本的输入输出流！！记住DBP天下任我闯！</li>
</ul>
</li>
</ul>
</li>
<li><p>面向字符</p>
<ol>
<li>Reader/Writer提供了兼容Unicode和面向字符的I/O功能</li>
</ol>
<ul>
<li>适配器adapter类：将“字节”和“字符”层次结构中的类结合来使用，如InputStreamReader将InputStream转化为Reader，OutputStreamWriter将OutputStream转化为Writer</li>
</ul>
<ol>
<li><p>来源和去处（\Reader/Writer）</p>
<blockquote>
<p>File\        对应fis/fos<br><br> String\        无对应的<br><br> CharArray\    对应bais/baos<br><br> Piped\        对应pis/pos<br></p>
</blockquote>
</li>
<li><p>更改流行为</p>
<blockquote>
<p>FilterReader<br><br> FilterWriter<br><br> BufferedReader    用它的readLine()比较多<br><br> BufferedWriter<br><br> DataInputStream    依旧不变，是I/O类库的首选成员～！但千万不能用他的readLine()<br><br> PrintWriter    能接受Writer也能接受OS～<br></p>
</blockquote>
</li>
</ol>
<ul>
<li>注意：close()被设为在finalize()运行时被调用，但是finalize()的特性并未如愿实现，唯一安全的方式是对各种IS/OS,Reader/Writer显示调用close()</li>
</ul>
</li>
<li><p>RandomAccessFile<br><br><em>一个完全独立的类，和IS/OS完全没有继承关系。本质上其实是类似把DataInputStream和DataOutputStream组合起来使用。</em></p>
<ul>
<li>适用于由大小已知的记录组成的文件。用seek()将记录从一处转移到另外一处，然后读取或修改记录。</li>
<li>java的DataInputStream/DataOutputStream和XML都很好的解决的特定平台的数据不统一问题。总之，java中，用dos输出的，用dis都能准确读取——无论读写平台有多不一样。</li>
<li>对象序列化和XML可能是更容易存储和读取复杂数据结构的方式。</li>
<li>创建：RandomAccessFile rf = new RandomAccessFile(filename, “r/rw”); <br>(<em>其中构造器参数r-只读，rw-读写</em>)</li>
</ul>
</li>
<li><p>标准I/O<br><br><em>“程序所使用的单一信息流”，程序中，所有输入都能来自标准输入System.in，所有输出都能输出到标准输出System.out，所有错误信息都可以发送到标准输出信息System.err。</em></p>
<ul>
<li>注意，out和err都是被包装成PrintStream的。但是System.in是一个未经加工的InputStream，需要被包装成BufferedReader来使用。</li>
</ul>
</li>
<li><p>nio<br><br><em>使用了通道Channel和缓冲器ByteBuffer，使得I/O速度提高</em></p>
<ul>
<li>FileChannel 可以向它传送用于文件读写的ByteBuffer，并且可以锁定文件的某些区域用于独占式访问。</li>
<li><p>得到管道和缓冲器的一般用法（都不能直接new，需要间接获取）：</p>
<blockquote>
<p>private static final int BSIZE = 1024;<br><br>  FileChannel fc = new FileInputStream(“data.txt”).getChannel();<br><br>  fc = new FileOutputStream(“datacopy.txt”).getChannel();<br><br>  ByteBuffer buff = ByteBuffer.allocate(BSIZE);<br></p>
<p>buff.put();    //put方法对ByteBuffer进行直接填充，填入1+个字节/基本数据类型，指针向后一位。<br>  buff.wrap(“abc”.getBytes()) //也可用wrap方法将已存在的字节数组“包装”到ByteBuffer中。<br>  ByteBuffer.allocate()    //对于只读访问，必须要显示调用静态allocate方法来指定</p>
</blockquote>
</li>
<li><p>缓冲器的方法：</p>
<blockquote>
<p>buffer.flip(); // 为打印字符做准备，让指针position从最末尾移到第一个位置，并将limit设置为当前位置<br><br>  buffer.rewind();//只让指针从最末端移到首位，不对limit做改动<br><br>  buffer.clear();  // Prepare for reading</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>转换数据：<br><br><em>缓冲器容纳的是普通的字节，为了把他们转换成字符，要么在输入时进行”编码”，要么在其从缓冲器输出时对其”解码”。(可以使用java.nio.charset.Charset实现。)</em></p>
<ol>
<li>通过打印时解码<blockquote>
<p><code>Charset.forName(&quot;编码方式&quot;).decode(&quot;缓冲器&quot;)</code></p>
</blockquote>
</li>
<li>通过输出到文件时字符串的.getBytes编码<blockquote>
<p><code>fc.write(buffer.wrap(&quot;text&quot;.getBytes(&quot;UTF-16BE&quot;)));</code></p>
</blockquote>
</li>
<li>利用当成CharBuffer写入和取出(view bufer)<blockquote>
<p>buffer.asCharBuffer().put(“text”);<br><br>System.out.println(buffer.asCharBuffer());</p>
</blockquote>
</li>
</ol>
</li>
<li><p>视图缓冲器view buffer<br><br><em>让ByteBuffer包装成其他特定数据类型，实际上底层还是ByteBuffer存储的。</em></p>
<ol>
<li><p>基本数据类型：</p>
<ul>
<li><code>ByteBuffer bb = ByteBuffer.allocate(1024);</code></li>
<li><code>IntBuffer ib = bb.asIntBuffer();</code></li>
<li><code>ib.put(new int[]{1,33});</code></li>
<li><code>ib.get();</code>//得到当前指针所在的位置的数值，并且让指针增加一位</li>
<li><code>ib.put(1);</code>//向Int视图的缓冲器存进一个整型，指针也增加一位    </li>
<li><code>ib.position();</code>//得到当前指针所在位置（根据数据类型字节数不同而不同）</li>
</ul>
</li>
<li><p>缓冲器的4个索引：</p>
<blockquote>
<p>mark        标记，mark()能将当前mark设置为position<br><br> position    位置，指针。reset()能将当前position设置为mark值<br><br> limit        界限<br><br> capacity    容量<br></p>
</blockquote>
</li>
<li><p>内存映射文件mapping：<br><br><em>将太大放不进内存的文件可以当做整个文件都在内存中，看做一个非常大的数组。</em></p>
<ul>
<li>得到一个缓冲器：<br>  <br><code>MappedByteBuffer out = fc.map(FileChannel.MapMode.Read_ONLY, 0, fc.size());</code><br>  <br>先得到通道，决定读写，然后指定映射文件的初始位置和映射区域长度</li>
<li>映射的write必须要用RandomAccessFile来输出！</li>
</ul>
</li>
</ol>
</li>
<li><p>文件加锁：<br> <br><em>允许我们同步访问某个作为共享资源的文件；</em></p>
<ul>
<li>文件锁对于其他操作系统进程是可见的，因为java文件加锁直接映射到了本地操作系统的加锁工具。</li>
<li>通过对FileChannel调用tryLock()<em>非阻塞式</em>或lock()<em>阻塞式</em>就可以得到整个文件的FileLock。</li>
<li>对于SocketChannel、DatagramChannel和ServerSocketChannel不需要加锁，因为他们是从单进程实体继承过来的。</li>
<li>查询锁的类型：FileLock.isShared()</li>
<li>对映射文件的加锁：<br>文件映射通常用于极大的文件，如数据库，我们可以对它部分加锁，以便多个用户访问它。</li>
</ul>
</li>
<li>压缩<ul>
<li>压缩类库需要按字节方式处理。有时要使用两种类型的数据流，可以通过适配器类进行转换<ul>
<li>DeflaterOutputStream 压缩类的基类</li>
<li>InflaterInputStream 解压缩类的基类</li>
<li><code>CheckedInputStream</code> 用GetCheckSum(),为InputStream产生校验和</li>
<li><code>ZipInputStream</code> 一个InflaterInputStream，用于解压缩Zip文件格式的数据</li>
<li><code>GZIPInputStream</code> 用于解压缩GZIP文件格式的数据</li>
</ul>
</li>
<li>Zip和GZIP是最常用的。</li>
<li>共有两种Checksum类，用来计算<em>和校验文件</em>(多个文件)的校验和的方法，Adler32（快些）和CRC32（慢些，但准确）</li>
<li>jar <strong>java档案文件</strong>，能够像zip一样将一组文件压缩到单个文件中。</li>
<li>使用：jar [option] destination [manifest] inputfiles</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li>java.lang.annotation.Annotation<ul>
<li>Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。</li>
</ul>
</li>
<li>java.lang.reflect.AnnotatedElement<ul>
<li>AnnotatedElement 接口代表程序中可以接受注解的程序元素，是所有程序元素（Class、Method、Field、Package和Constructor）的父接口。获取该接口对象之后，即可以调用对象方法来访问Annotation信息，常用有如下几个：<ol>
<li>getAnnotations()：返回该程序元素上存在的所有注解。</li>
<li>isAnnotationPresent(annotation.class)：判断该程序元素上是否包含指定类型的注解</li>
<li>getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol>
<li>作用<ul>
<li>要处理很多任务，要将他们交织在一起，应用并发能够更有效地利用计算机</li>
<li>能够更好地组织代码</li>
<li>要更便于用户使用</li>
</ul>
</li>
<li><p>注意点</p>
<ul>
<li>可以运行多个独立的任务</li>
<li>必须考虑这些任务关闭时，可能出现的所有问题</li>
<li>任务可能在共享资源上彼此相互交涉，互斥锁可以用来避免这种冲突</li>
<li>如果任务设置不仔细，可能会出现死锁</li>
</ul>
</li>
<li><p>基本</p>
<ul>
<li>Runnable接口</li>
<li>Thread类</li>
<li>Executors类管理多个不同的Thread<ul>
<li>CachedThreadPool 最常用的能够为每个task提供1个thread</li>
<li>FixedThreadPool 决定了thread的总数，一般考虑提高效率才用到它</li>
<li>SingleThreadPool (不需要考虑同步问题）只有一条thread，没轮到的只能堵塞，每个task完成之后结束对thread的占用</li>
<li>shutDownNow() 对所有的tasks逐个调用interrupt()，state = STOP，停止所有正在执行/等待执行的tasks</li>
<li>shutDown() 相对温柔，state = SHUTDOWN，不能往线程池添加任务，对等待线程池中tasks调用interrupt,停止所有等待执行的tasks</li>
</ul>
</li>
<li>Callable <em>call()而不是run()</em><ul>
<li>submit()产生Future对象，参数化call()的返回值</li>
<li>get()得到Future的返回值对象，直到isDone()==true之前都是堵塞的</li>
<li>isDone()判断Future对象是否完成返回参数</li>
</ul>
</li>
<li>sleep 更加直观的Java SE5用法：TimeUnit.SECONDS.sleep(10);</li>
<li>setPriority 在构建器中设置priority并没有好处，因为这时候的task还没启动（通常在run()里早点设置）<ul>
<li>不同操作系统优先等级也不尽相同，虽然JDK提供10个等，但通常用Thread.MAXMAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY三个，提供可移植性</li>
</ul>
</li>
<li>volatile 关键字，保证编译器不会对数据做优化处理</li>
<li>yield 使得<em>同等优先级</em>的thread有机会运行（不能保证）</li>
<li>daemon 后台线程，但都是些无关紧要的。只要所有non-daemon都结束了，daemon线程立马完蛋，随时被断<ul>
<li>daemon线程中创建的任何线程会自动地变成daemon的</li>
</ul>
</li>
<li>ThreadFactory 一个类，传入Runnable，还你一个Thread,可以作为参数传入重载的Executors.newCachedThreadPool()<ul>
<li>可以方便地指定生产出来的线程是否daemon、是否UncaughtExceptionHandler及其他操作</li>
</ul>
</li>
<li>join() 将一个新的thread强行插入当前thread中间，原来的thread被挂起，直到加入的thread结束<ul>
<li>join可以重载一个超时参数，超过一定时间新thread还没结束就回到原来的thread</li>
<li>用类库中的构件如CyclicBarrier比join()会更合适</li>
</ul>
</li>
<li>isInterrupted() 如果当前有中断发生，就会变成true。<ul>
<li>但是在中断异常被捕捉到之后，原来的结果就会被清空。所以在catch语句中它为false</li>
</ul>
</li>
<li>interrupt()<ul>
<li>sleep()是interruptible的方法，synchronized和IO是不可中断的方法</li>
</ul>
</li>
<li>Future 可以用submit()代替execute()来启动线程<ul>
<li>不同的是前者能够返回一个Future对象，这个Future虽然不能get()到什么东西，但是可以用close中断线程</li>
</ul>
</li>
<li>Thread.setDefaultUncaughtExceptionHandler() 可以指定主线程中的uncaughtExeption()来处理<ul>
<li>通常情况下，Thread中的异常不能被外部的其他线程处理</li>
</ul>
</li>
<li>synchronized 能够提供上锁状态，在上锁状态里没有其它线程能够截断里面的操作，直到操作完成<ul>
<li>使用private关键字也很重要，否则并不能阻止其他线程对上锁区间的访问</li>
<li>对重要的共同资源的访问的<strong>所有相关方法</strong>都必须有锁</li>
</ul>
</li>
<li>lock 使用lock.lock()和lock.unlock()同样能上锁<ul>
<li>性能上lock比synchronized好些</li>
<li>lock还提供了tryLock：尝试获取上锁状态、尝试获取锁超时自动放弃等功能</li>
</ul>
</li>
<li>volatile 关键词，简单但又非常容易出错，读取性能好，说明某个参数可能会被意想不到地改变<ul>
<li>一般来说，除了long和double之外的基本类型都是原子性的，也就是说自动在上锁状态下完成读写返回等</li>
<li>使用了volatile关键字，能够让long、double也拥有原子性</li>
<li>保证了可见性，即释放锁之前对共享数据的更改，对下一个获得该锁的线程是可见的。保证了共享数据的同步</li>
<li>用于作为状态标识，让flag可以被多个线程访问：通常编译器优化是指编译器只会保存最后一个被修改的本线程参数值，但是在多线程工作中，一个参数可能会在另外一个线程中被修改，因此需要将每个变化值保存在寄存器里，即不做优化</li>
</ul>
</li>
<li>AtomicInteger 通过用封装对象类使用primitive，自动是同步的，省掉了synchronized</li>
<li>ThreadLocal 线程安全的共享对象<ul>
<li>除了synchronize之外的另外一个防止共同资源被错误地修改的办法，就是消除变量的共享</li>
<li>为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。<em>相当用空间换时间</em></li>
</ul>
</li>
<li>线程状态：<ul>
<li>New</li>
<li>Runnable 这里是一个就绪状态，might or might not be running at any moment</li>
<li>Blocked</li>
<li>Dead</li>
</ul>
</li>
<li>wait()/notifyAll() for Object, await()/signal() for Condition<ul>
<li>wait()能够挂起线程，使得它的锁能够被释放和重用，和sleep/yield的占用锁不同</li>
<li>wait()重载：一种和sleep类似，有参数n，能够等待n个毫秒，但是可以被notify叫醒；一种无参数，常用，等待直到被notify</li>
<li>wait() 应用一个某条件的的while包围起来，直到while里面满足特定的条件，否则该线程应被一直挂起</li>
<li>锁也是所有对象的一部分，非synchronized块中想要调用wait/notifyAll等方法前必须获取锁（新建一个synchronized(Object)块）</li>
<li>notifyAll()的作用是叫醒当前Object锁上面所有wait的线程，使得它们能够被调用（但不代表会被调用）</li>
<li>单个的Lock将产生一个Condition对象，它需要在锁里用且允许挂起，主要作用是显式实现一个睡/醒对象</li>
<li>signalAll()比notifyAll()要更加安全 </li>
</ul>
</li>
<li>同步队列：LinkedBlockingQueue/ArrayBlockingQueue<ul>
<li>在任何时候都只允许一个task插入或移除元素</li>
<li>比用wait()/notifyAll()简化和更可靠</li>
<li>如果task尝试从queue中取出一个对象而queue里面是空的，queue将会挂起直到有更多元素时恢复</li>
<li>将任务从main()中的线程池转移到了Queue中，在别的方法里面就可以建立线程，启动/中断</li>
<li>一般是一个queue一个线程，它里面的tasks都是用的这个线程，因为queue里面元素是互斥的，不用考虑synchronized问题</li>
</ul>
</li>
<li>PipedReader/PipedWriter 用于线程间通信，看做是生产者消费者的变体。<ul>
<li>PipedWriter是一个独立的对象，而PipedReader必须在构造器中传入一个PipedWriter</li>
<li>当PipedReader调用时，会检测PipedWriter，如果没有更多的数据将自动堵塞</li>
<li>最大不同：可以中断的<em>普通IO不可中断</em></li>
<li><blockquote>
<p>能用BlockingQueue的地方就可以忘掉管道了</p>
</blockquote>
</li>
</ul>
</li>
<li>BlockingQueue<ol>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ol>
</li>
<li>死锁四个条件<ol>
<li>相互排斥。至少有1个资源是不可分享的</li>
<li>至少一个任务本身持有资源，却又等着要从另外一个任务中拿到资源</li>
<li>资源不能够被任务抢占，任务必须把资源释放当做普通事件</li>
<li>使得环形等待能够发生，一个任务在等待另外一个任务中的资源，那个任务反过来也在等这个任务的资源</li>
</ol>
<ul>
<li>防止死锁最容易的方法就是破坏第四个条件，阻止环形等待出现</li>
</ul>
</li>
<li>TimeUnit 是一个帮助统一时间表达的枚举类<ul>
<li>它本身不包含时间信息，但能够实现不同时间单位之间的转换</li>
<li>它能够将long类型的时间转变为方便读懂的对象，也返回long类型的时间</li>
</ul>
</li>
<li>System中计算时间的方法<ul>
<li>nanoTime() 可以计算精确时间，单位是nanosecond，它的值和日期无关（仅用于测量时间的相对变化）</li>
<li>nanoTime 返回值甚至可以为负的，因为它看重的只是纳秒级的时间差</li>
<li>currentTimeMillis() 以millisecond返回当前时间，可以用来计算日期、与Date转换</li>
<li>currentTimeMilis 返回的是1970-1-1凌晨到现在的毫秒数，为绝对时间</li>
</ul>
</li>
</ul>
</li>
<li>新类库的构件</li>
</ol>
<ul>
<li>通过PriorityQueue，使得超时的Item最先被处理，利用BlockingQueue，将Item处理的操作阻塞住。避免了遍历方式的轮训，提高了性能。在很多需要回收对象的场景都能用上。<ul>
<li>CountDownLatch （倒数门闩）用来synchronize一个或多个任务<ul>
<li>所有tasks中CountDownLatch.awaits()的调用都会被堵塞</li>
<li>直到tasks调用的CountDownLatch.countDown()使count达到0之时，tasks中被堵塞的(awaits)才会运行</li>
<li>注意awaits和countDown中应工作在同一个CountDownLatch上</li>
<li>初始计数值count不能被重置</li>
<li>用于将一个问题分割成n个独立的可解决任务</li>
</ul>
</li>
<li>CyclicBarrier 循环栏杆 = 可复用的倒数门闩CountDownLatch<ul>
<li>指定数量n（参数#1）的synchronize的tasks共同完成之后，栏杆失效。</li>
<li>执行（参数#2）一个栏杆的最后动作Runnable（或不执行），该动作依附最后一个task的thread上执行，推进到下一轮</li>
<li></li>
</ul>
</li>
<li>DelayQueue&lt;? extends Delayed&gt; <ul>
<li>是PriorityQueue的一个变体</li>
<li>成员必须实现Delayed接口，这个接口的实现方法compareTo()/getDelay()决定了成员的优先顺序</li>
<li>哪个成员被踢出expire队列由它们谁更“紧急”（即delay时间最短\最delay no more的）决定</li>
<li>作用<ul>
<li>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</li>
<li>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</li>
</ul>
</li>
</ul>
</li>
<li>Deque 用于取代Stack</li>
</ul>
</li>
</ul>

            
        
        </div>
        
            
            
        
    </article>
    
        
    <nav class="article-page">
        
        
            <a href="/swanf/2017/11/08/Java/" id="art-right" class="art-left">
                <span class="prev-title"> 
                    <i class="iconfont icon-left"></i>Java
                </span>
            </a>
        
    </nav>

        
    


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
        
        
        
        
            <a href="https://www.zhihu.com/people/swanfuck" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
    
        
            <a href="https://github.com/swanf" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2017 ~ 2017</span>
        <span>❤</span>
        <span>swanf</span>
    </div>
    <div class="theme">
        <span>
            动力来源于
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            主题
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/swanf/script/nlvi.js"></script>
<script src="/swanf/script/search.js"></script>

    <script src="/swanf/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.mobileHeader();
    Nlvi.back2top();
    Nlvi.smoothScroll();
    Nlvi.onView();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward();
    Nlvi.picPos();

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
        
    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
    
    <div class="search" id="search">
        <div class="mask" id="mask"></div>
        <div class="search-wrapper syuanpi">
            <h1 id="search-header" class="syuanpi">搜索一下？</h1>
            <div class="input">
                <input type="text" id="local-search-input" results="0" name="">
            </div>
            <div id="local-search-result"></div>
        </div>
    </div>
    <script>
    var GREETING = {
        morning: "充满电，开始探索世界。",
        noon: "不疾不徐，阳光给与你能量。",
        after: "慢慢地，你要学会做自己的太阳。",
        night: "后来，夜也因你而透亮。",
        midnight: "在夜里，你也活得如同白昼。"
    }
    $(document).ready(function(){
        Nlvi.search();
    });
    </script>

</body>
</html>
