{"pageProps":{"post":{"title":"Node.js 的模块加载","date":"2021-07-15","slug":"node-js-modules","content":"<h1>Node.js 模块的加载</h1>\n<p>最初 JS 没有模块导入/导出的概念，想象我们在紧巴巴的一个文件里写一个 app，这简直是个噩梦啊！</p>\n<p>后来，人们设想增添一些模块化的思维，它们是：CJS，AMD，UMD 和 ESM。\r\n<img src=\"https://cdn.nlark.com/yuque/0/2021/jpeg/12362795/1626276928489-c227455f-13cf-429c-94b6-b6d19d9f249e.jpeg\" alt=\"\">Node.js 模块加载通常分为两种格式，【1】老早就支持的 CommonJS（CJS，模块格式，和【2】直到 v13.2 才支持的 ES Module （ESM，ES6 模块格式）。</p>\n<blockquote>\n<p>二者语法区别：<a href=\"https://juejin.cn/post/6938581764432461854\">https://juejin.cn/post/6938581764432461854</a></p>\n</blockquote>\n<p>Node.js 加载 <strong>ES6 模块</strong>要求满足以下其中一点：</p>\n<ol>\n<li>添加 <code>.mjs</code>  后缀名，将被自动识别为 ES6 模块</li>\n<li>在 <code>package.json</code>  中指定 <code>\"type\":\"module\"</code>，所有 <code>.js</code>  文件将会被自动解释为 ES6 模块</li>\n<li>在命令行里，执行 <code>node --experimental-modules xx.js</code></li>\n</ol>\n<p><a href=\"https://irian.to/blogs/what-are-cjs-amd-umd-and-esm-in-javascript/\">https://irian.to/blogs/what-are-cjs-amd-umd-and-esm-in-javascript/</a></p>\n<h3>CJS</h3>\n<p>全称 CommonJS</p>\n<pre><code>// importing\r\nconst doSomething = require(\"./dosomething.js\");\r\n\r\n// exporting\r\nmodule.exports = function doSomething(n) {\r\n  // do something\r\n};\n</code></pre>\n<ul>\n<li>你可能觉得似曾相识，因为 Node.js 默认的模块格式就是 CJS</li>\n<li>你能够从 <code>node_modules</code>  或者本地目录中导入一个库来使用， 如通过 <code>const myLocalModule = require('./some/local/file.js')</code>  或者 <code>var React = require('react')</code></li>\n<li>CJS 引入时，它会给你一份引入的对象的<strong>拷贝</strong></li>\n<li>CJS 在浏览器中不起作用，它需要被转译和打包（transpiled and bundled）</li>\n</ul>\n<h3>AMD</h3>\n<p>全称 Asynchronous Module Definition</p>\n<pre><code>define([\"dep1\", \"dep2\"], function (dep1, dep2) {\r\n  // Define the module value by returning a value\r\n  // 在这里就可以使用上述引入的两个模块了\r\n  return function () {};\r\n});\n</code></pre>\n<p>或者如下（类似 CJS 的形式）</p>\n<pre><code>// \"simplified CommonJS wrapping\" https://requirejs.org/docs/whyamd.html\r\ndefine(function (require) {\r\n  var dep1 = require(\"dep1\"),\r\n    dep2 = require(\"dep2\");\r\n  return function () {};\r\n});\n</code></pre>\n<ul>\n<li>AMD 异步地引入模块（Asynchronous ...）</li>\n<li>AMD 适用于前端（浏览器），它就是为这而设的，相对于用于后端的 CJS</li>\n<li>AMD 语法比起 CJS 没那么直观，实际上这正好和 CJS 相反。</li>\n</ul>\n<h3>UMD</h3>\n<p>全称 Universal Module Definition</p>\n<pre><code>(function (root, factory) {\r\n  if (typeof define === \"function\" &#x26;&#x26; define.amd) {\r\n    define([\"jquery\", \"underscore\"], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    module.exports = factory(require(\"jquery\"), require(\"underscore\"));\r\n  } else {\r\n    root.Requester = factory(root.$, root._);\r\n  }\r\n})(this, function ($, _) {\r\n  // this is where I defined my module implementation\r\n\r\n  var Requester = {\r\n    // ...\r\n  };\r\n  return Requester;\r\n});\n</code></pre>\n<ul>\n<li>前端后端都能用（所以 Universal ...）</li>\n<li>不同于 CJS 和 AMD，UMD 更像一个约定俗成的代码写法（patterns），人们可以 polyfill 去配置满足多个模块系统的使用情景需求，更多 patterns 参考 <a href=\"https://github.com/umdjs/umd/\">https://github.com/umdjs/umd/</a></li>\n</ul>\n<h3>ESM</h3>\n<p>全称 ES Modules，是一个 JS 官方提议的标准</p>\n<pre><code>import React from \"react\";\n</code></pre>\n<p>或者</p>\n<pre><code>import {foo, bar} from './myLib';\r\n\r\n...\r\n\r\nexport default function() {\r\n\t// do something...\r\n}\r\nexport const function1() {...};\r\nexport const function2() {...};\n</code></pre>\n<ul>\n<li>在很多<a href=\"https://caniuse.com/#feat=es6-module\">现代浏览器</a>里都能使用</li>\n<li>两全其美！跟 CJS 类似的语法，但是又能够用 AMD 的异步</li>\n<li>Tree-shakable！能够优化 webpack 打包的体积，得益于 ES6 的静态模块结构</li>\n<li>ESM 允许打包器如 Rollup 移除不必要的代码，从而减少打包后 js 文件的大小</li>\n<li>能够在 HTML 中调用，只需要做：</li>\n</ul>\n<pre><code>&#x3C;script type=\"module\">import {func1} from 'my-lib'; func1();&#x3C;/script>\n</code></pre>\n<blockquote>\n<p>以上代码不保证在所有浏览器中 100% 运行</p>\n</blockquote>\n<h3>总结</h3>\n<ul>\n<li>ESM 是最好的模块格式，好语法+1，异步加载+1，可 tree-shake +1，满分！</li>\n<li>UMD 能够在所有地方运行，通常作为 ESM 不能使用的 fallback 替补</li>\n<li>CJS 同步且适用于后端</li>\n<li>AMD 异步且适用于前端</li>\n</ul>\n"}},"__N_SSG":true}