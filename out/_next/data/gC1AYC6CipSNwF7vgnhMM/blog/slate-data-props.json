{"pageProps":{"post":{"title":"从 Slate 的内置特性到洋葱模型","date":"2022-04-15","slug":"slate-data-props","content":"<h2>Slate 的属性 props 和特性 attributes</h2>\n<p>在 Slate 的文档中，有一句<a href=\"https://docs.slatejs.org/concepts/09-rendering#leaves\">提醒</a>，“请确保将 <code>props.attributes</code> 混入到自定义的组件中，并且在自定义组件中渲染 <code>props.children</code>“。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb64474cc4f44692bbf5db85a86abcf2~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Screenshot from 2022-04-14 21-37-23.png\"></p>\n<p><code>props</code> 泛指父组件传入子组件的参数，而其中的 <code>attributes</code> 是指 Slate 在渲染过程中所需的内置特性，<code>children</code> 则是指代 Slate 接管并负责渲染的文本组件。</p>\n<p>那这个 <code>attributes</code> 为什么如此重要？本文将带着这个问题一探究竟。</p>\n<h2>Slate 的自定义内置特性</h2>\n<p>在 Slate 的开发过程中，经常会看到一些 <code>data-</code> 开头的<strong>自定义内置特性</strong>（attribute），比如 <code>data-slate-node</code> 等。将这些内置特性列举如下：</p>\n<h3>Editable</h3>\n<ul>\n<li><code>data-slate-editor</code> 用于标识编辑器组件。</li>\n</ul>\n<h3>Element</h3>\n<ul>\n<li>\n<p><code>data-slate-node</code>: 必须，取值有 <code>'element'|'value'|'text'</code>，分别代表元素、文档全量值（适用于 <code>Editable</code> 上）、文本节点（适用于 <code>isInline</code> 的元素）。</p>\n</li>\n<li>\n<p><code>data-slate-void</code>: 若为空元素则取值为 <code>true</code>，否则不存在。</p>\n</li>\n<li>\n<p><code>data-slate-inline</code>: 若为内联元素则取值为 <code>true</code>，否则不存在。</p>\n</li>\n</ul>\n<p>此外，对于 <code>Element</code> 的 <code>attributes</code> 中还有以下内置特性内容：</p>\n<ul>\n<li>\n<p><code>contentEditable</code>: 若不可编辑则取值为 <code>false</code>，否则不存在。</p>\n</li>\n<li>\n<p><code>dir</code>: 若编辑方向为从右到左则取值 <code>'rtl'</code>，否则不存在。</p>\n</li>\n<li>\n<p><code>ref</code>: 必选，当前元素的 ref 引用。Slate 会在每次 <code>Element</code> 渲染时将该元素和其对应 DOM 节点的映射关系添加到 <code>ELEMENT_TO_NODE</code> 的 WeakMap 中。若缺少 ref 则会因为 <code>ELEMENT_TO_NODE</code> 中映射关系的缺失而导致渲染失败和 <code>toSlateNode</code> 中报错。</p>\n</li>\n</ul>\n<h3>Leaf</h3>\n<ul>\n<li><code>data-slate-leaf</code>: 必须，取值为 <code>true</code>，表明对应 DOM 元素为 Leaf 节点。</li>\n</ul>\n<h3>String</h3>\n<ul>\n<li>\n<p><code>data-slate-string</code>: 若为文本节点则取值为 <code>true</code>，否则不存在。</p>\n</li>\n<li>\n<p><code>data-slate-zero-width</code>: 若为零宽度文本节点则取值 <code>'n'|'z'</code>，分别指代换行、不换行，否则不存在。</p>\n</li>\n<li>\n<p><code>data-slate-length</code>: 用于标注零宽度文本节点的实际宽度，单位为字符数。默认为 0，如果不为零则为被设置了 <code>isVoid</code> 的元素的文本字符的宽度。</p>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li><code>data-slate-spacer</code>: 设置了 <code>isVoid</code> 的 <code>Element</code> 外面会包裹一层元素，这个包裹元素会含有该自定义特性，以便区分普通元素，并用于掌管该空元素相关的行为（复制、光标聚焦、光标失焦等）。</li>\n</ul>\n<h2>Slate 的洋葱模型</h2>\n<p>Slate 中的组件层级可以用下图表示：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b69848e1c7b4b1eb9e28cb17742320e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Slate-onion-model.png\"></p>\n<p>Slate 本质上是一个<strong>洋葱模型</strong>，从外到内分别为：</p>\n<ul>\n<li><code>Slate</code> 一个编辑器组件外包裹层，用于接管 <code>Editable</code> 的 <code>onChange</code> 事件。</li>\n<li><code>Editable</code> 本质上是一个 Textarea 元素的超集，这一点也体现在它的<a href=\"https://github.com/ianstormtaylor/slate/blob/5160efeea492fa52c462e0a9f14189b5dc18c48e/packages/slate-react/src/components/editable.tsx#L110\">参数类型</a>上。是一个可变的单例编辑器实例。</li>\n<li><code>Children</code> 孩子组件，用于接管 <code>Editable</code> 的 <code>children</code> 属性，并负责往下渲染 <code>Element</code>。</li>\n<li><code>Element</code> 元素，从根节点 <code>editor</code> 往下的一级节点，代表元素实例，每个元素都有一个 <code>type</code> 属性用于标识其类型。使用 <code>renderElement</code> 方法渲染，可添加自定义属性和样式。在这层更新<em>元素节点层级</em>的映射关系。</li>\n<li><code>Text</code> 文本组件，用于接管 <code>Element</code> 的 <code>children</code> 属性，并负责往下渲染 <code>Leaf</code>。在这层更新<em>叶子节点层级</em>的映射关系。</li>\n<li><code>Leaf</code> 叶子，从根节点 <code>editor</code> 往下的二级节点，每个叶子都有一个 <code>text</code> 属性给 <code>String</code> 进行文字渲染。使用 <code>renderLeaf</code> 方法渲染,可添加自定义属性和样式。</li>\n<li><code>String</code> 最底层的文本元素，文本输入时和浏览器的 <code>DOM</code> 真正交互所在位置，并没有和虚拟 DOM 层做“视图-数据”绑定，因为这个位置 <code>contentEditable</code> 的 <code>DOM</code> 原生地支持文本输入。比如输入一个字符，则会在这里触发一次 <code>onChange</code> 事件并冒泡到 <code>Slate</code> 上接管处理。</li>\n</ul>\n<p>因为 Slate 洋葱模型的缘故，所有元素的特性都是直接挂载在对应的 DOM 节点上，每一个对应层级就会有该层级对应的 <code>attributes</code> 内置特性用于标注该层节点的信息（如内联元素，会对应拥有 <code>data-slate-inline=\"true\"</code>），比如 <code>Element</code> 的内置特性就是 <code>data-slate-node=“element\"</code>，<code>Leaf</code> 的内置特性就是 <code>data-slate-leaf</code>。</p>\n<h2>开发一个自定义组件</h2>\n<p>Slate 中涉及到自定义组件或者自定义文本节点属性，这时候会使用到 <code>slate-react</code> 的 renderLeaf 和 renderElement。</p>\n<p>下面简单开发一个自定义组件来加深对洋葱模型的理解：</p>\n<pre><code>function App() {\r\n  const editor = useMemo(() => withReact(createEditor()), []);\r\n  const [value, setValue] = useState([\r\n    {\r\n      type: \"paragraph\",\r\n      children: [\r\n        {\r\n          text: \"This is editable \",\r\n        },\r\n      ],\r\n    },\r\n    {\r\n      type: \"block-quote\",\r\n      children: [\r\n        {\r\n          text: \"This is block quote \",\r\n        },\r\n      ],\r\n    },\r\n  ]);\r\n\r\n  const renderElement = ({ children, element, attributes }) => {\r\n    return &#x3C;DefaultElement {...{ children, element, attributes }} />;\r\n  };\r\n\r\n  const DefaultElement = ({ children, element, attributes }) => {\r\n    if (element.type === \"block-quote\") {\r\n      return &#x3C;blockquote style={{ fontFamily: \"fantasy\" }}>{children}&#x3C;/blockquote>;\r\n    }\r\n    return &#x3C;div {...attributes}>{children}&#x3C;/div>;\r\n  };\r\n\r\n  return (\r\n    &#x3C;div className=\"App\">\r\n      &#x3C;Slate editor={editor} value={value} onChange={(val) => setValue(val)}>\r\n        &#x3C;Editable renderElement={renderElement} />\r\n      &#x3C;/Slate>\r\n    &#x3C;/div>\r\n  );\r\n}\r\n\r\nexport default App;\n</code></pre>\n<p>以上为添加一个自定义的 <code>block-quote</code> 组件的普通做法，但是按照我们刚刚的思路，也能够将洋葱模型背后的面纱揭开，直接把 <code>block-quote</code> 组件的完整渲染结果作为 <code>DefaultElement</code> 的返回值。</p>\n<p>我们将上述的 <code>DefaultElement</code> 重写为：</p>\n<pre><code>const DefaultElement = ({ children, element, attributes }) => {\r\n  if (element.type === \"block-quote\") {\r\n    return (\r\n      &#x3C;blockquote data-slate-node=\"text\" ref={attributes.ref} style={{ fontFamily: \"fantasy\" }}>\r\n        &#x3C;span data-slate-leaf=\"true\" contenteditable=\"true\">\r\n          &#x3C;span data-slate-string=\"true\">{children[0].props.text.text}&#x3C;/span>\r\n        &#x3C;/span>\r\n      &#x3C;/blockquote>\r\n    );\r\n  }\r\n  return &#x3C;div {...attributes}>{children}&#x3C;/div>;\r\n};\n</code></pre>\n<p>重写后的 <code>block-quote</code> 组件实际上和渲染出来的 DOM 结构层级几乎一致，将组件的渲染结果直接返回。其层级结构符合 Slate 的洋葱模型。</p>\n<blockquote>\n<p>注意：实践中并不建议这样做，因为这样会丢失了叶子节点作为自定义组件的一部分所包含的信息，而叶子节点的渲染结果是不可预知的，因此这样做的话，可能会导致渲染结果不一致。</p>\n</blockquote>\n<blockquote>\n<p>此外，在 Slate 的实现中，分别在 <code>Element</code> 和 <code>Text</code> 两个层级都更新了弱映射 <code>ELEMENT_TO_NODE</code>，而上述 demo 实际上是没有更新的该弱映射的，所以会出现以下报错：<code>Uncaught Error: Cannot get the leaf node at path [1] because it refers to a non-leaf node: [object Object]</code></p>\n</blockquote>\n<h2>toSlateNode 报错</h2>\n<p>使用 Slate 的 <code>slate-react</code> 层渲染引擎时会经常遇到这样的报错，这个是 <code>slate-react</code> 层本身的设计局限导致的。</p>\n<pre><code>Uncaught Error: Cannot resolve a Slate node from DOM node: [object HTMLDivElement]\r\n    at Object.toSlateNode (react-editor.ts:391:1)\r\n    at editable.tsx:761:1\n</code></pre>\n<p>这是因为通过事件获取到的 DOM 节点在 <code>ELEMENT_TO_NODE</code> 弱映射中<strong>没有对应的键值对</strong>，所以会导致无法从 DOM 元素中映射到对应的 Slate 节点。</p>\n<p>在实践中，我们为特定节点添加了自定义的 <code>data-ignore-slate</code> 属性，这样就能够在调用 <code>toSlateNode()</code> 的时候对含有该属性的节点进行<strong>过滤</strong>，避免报错。</p>\n<pre><code>if (domNode?.hasAttribute?.(\"data-ignore-slate\")) return;\n</code></pre>\n<h2>总结</h2>\n<p>从 Slate 的 <code>attributes</code> 出发，我们认识到了这些内置特性的功能都有哪些，是如何将 Slate 携带的信息存放到渲染出来的 DOM 节点里的。</p>\n<p>并且从顶到下认识了 <code>slate-react</code> 是如何一层一层将数据包裹起来，像一个洋葱模型一样。Slate 节点的数据通过分层映射管理，一层一层地转化为对应页面上的 DOM 节点。</p>\n"}},"__N_SSG":true}