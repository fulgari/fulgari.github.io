<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="referrer" content="no-referrer"/><meta name="next-head-count" content="3"/><link rel="preload" href="https://pzij.github.io/_next/static/css/d18bc53d6efe1b68.css" as="style"/><link rel="stylesheet" href="https://pzij.github.io/_next/static/css/d18bc53d6efe1b68.css" data-n-g=""/><link rel="preload" href="https://pzij.github.io/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="https://pzij.github.io/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://pzij.github.io/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pzij.github.io/_next/static/chunks/webpack-e09df0756682281e.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/framework-cdb3b77137bd004f.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/main-177456dd4f77fcee.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/_app-76d5ff31e5e3402a.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/6-82bf2f3c231febcd.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/448-efa4045d3d969541.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-ba16d42eb0ee523f.js" defer=""></script><script src="https://pzij.github.io/_next/static/vbjdjV-VpDLSvDSeVLm1q/_buildManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/vbjdjV-VpDLSvDSeVLm1q/_ssgManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/vbjdjV-VpDLSvDSeVLm1q/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container mx-auto px-[5vw] max-w-screen-xl"><div class="mb-32"><header class="flex justify-between items-center my-10 h-52 bg-no-repeat bg-center"><div class="logo ml-8 flex justify-start items-center cursor-pointer scale-110 transition-transform hover:scale-105"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2772%27%20height=%2772%27/%3e"/></span><img alt="Jun" href="/" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Jun" href="/" srcSet="https://pzij.github.io/qun.png 1x, https://pzij.github.io/qun.png 2x" src="https://pzij.github.io/qun.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></div><ul class="list-none float-right mr-8"><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/">Home</span><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/about">About</span><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/contact">Contact</span></ul></header><title>富文本编辑器框架 ProseMirror、Slate 和 Lexical 横向比较<!-- --> | J.P.</title><h1 class="text-3xl flex justify-center items-center underline" style="text-decoration-color:#14eb8f;margin-bottom:2em">富文本编辑器框架 ProseMirror、Slate 和 Lexical 横向比较</h1><div class="blog-post-container"><h2>富文本编辑器的实现</h2>
<p>通常使用 <a href="https://static001.geekbang.org/con/44/pdf/3673881710/file/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B-%E7%BD%97%E9%BE%99%E6%B5%A9.pdf">L1</a> 方案的富文本编辑器都是基于浏览器自身 <code>contentEditable</code> 属性实现的，共用了浏览器的光标和选区；对数据层进行了抽象，依赖 DOM 对内容进行渲染。</p>
<p>L1 富文本编辑器的重点在于实现视图层和数据层的双向绑定，确保视图层的改动。</p>
<p>本文将对以下三个的 L1 富文本编辑器进行横向比较。</p>
<ul>
<li><a href="https://github.com/ProseMirror/prosemirror">ProseMirror</a> @0.6.0</li>
<li><a href="https://github.com/ianstormtaylor/slate">Slate</a> @v0.60.17</li>
<li><a href="https://github.com/facebook/lexical">Lexical</a> @0.3.11</li>
</ul>
<p>三者对于视图层绑定到数据层的实现各不一样。</p>
<ul>
<li>ProseMirror 通过 JS 的原生 DOM 操作做了一层封装实现渲染。</li>
<li>Slate 通过插件化管理，将所有功能抽象成插件，不限定渲染框架。官方给出的是 <code>slate-react</code> 进行渲染，但是也可以用 <a href="https://github.com/worktile/slate-angular">Angular</a>、<a href="https://github.com/marsprince/slate-vue">Vue</a> 等前端框架实现视图层的渲染。</li>
<li>Lexical 同 Slate 也使用了插件化。官方通过 <code>lexical-react</code> 进行渲染，但是并<a href="https://github.com/facebook/lexical/blob/main/docs/design.md">不拘泥于特定框架</a>实现视图层。由于 Lexical 的数据结构是 Map 映射集合而不是普通对象，在渲染时需要先使用 <a href=""><code>reconcileNode()</code></a> 这个方法进行节点映射集合的遍历。</li>
</ul>
<h2>编辑器实例</h2>
<h4>ProseMirror</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c091176b4ef4064a5ec9a36a6a82a01~tplv-k3u1fbpfcp-zoom-1.image" alt="PM instance"></p>
<p>定义：<a href="https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/main.js"><code>src/edit/main.js</code></a></p>
<p>ProseMirror 编辑器实例，使用 class 实现，<code>pm.doc</code> 代表文档的根 Node 节点，<code>pm.sel</code>代表文档的当前选区。</p>
<p>ProseMirror 的文档节点可以分为三大类型，<code>Node</code>、<code>Fragment</code> 和 <code>Mark</code>，分别代表基本节点、基本节点数组和节点标记。</p>
<ul>
<li><code>Node</code> 可以拓展成为 <code>TextNode</code>，或者按照给定的 <code>schema</code> 拓展成为特定的 <code>NodeType</code> 进而用于代表段落、标题等。</li>
<li><code>Fragment</code> 类似一个容器，主要是将其 <code>content</code> 属性中的基本节点数组包起来。</li>
<li><code>Mark</code> 类似一个占位符，用来表现某一个 <code>TextNode</code> 所含有的特征。</li>
</ul>
<h4>Slate</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e62bc858758c4f83a2de7ffedd593eec~tplv-k3u1fbpfcp-zoom-1.image" alt="Slate instance"></p>
<p>定义：<a href="https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/create-editor.ts"><code>packages/slate/src/create-editor.ts</code></a></p>
<p>Slate 的实例对象，与 ProseMirror 用类实现不同，Slate 采用了纯对象表示编辑器实例。</p>
<blockquote>
<p>Slate 的早期也是基于 class 实现的，但是从 Immutable.js 切换到 Immer 的<a href="https://github.com/ianstormtaylor/slate/issues/2345#issue-374819376">重构</a>后，转向了使用纯 JS 对象作为数据结构。</p>
</blockquote>
<p>该实例节点就是文档的根节点，可以从 <code>editor.children</code> 获取到整个文档所有的子节点；<code>editor.selection</code> 代表文档的当前选区。</p>
<h4>Lexical</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d741b849fa4826af2e8f7fb8e1e190~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>定义：<a href="https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical/src/LexicalEditor.ts"><code>packages/lexical/src/LexicalEditor.ts</code></a></p>
<p>Lexical 编辑器实例，使用 class 实现，<code>editor._editorState._nodeMap</code> 代表文档的节点合集，<code>editor._editorState._selection</code> 代表文档的当前选区。</p>
<p><strong>Lexical 的独特之处</strong></p>
<p>Lexical 的节点是通过 Map 存储的（如下图），这和 Slate、ProseMirror 的树状数据结构有本质差异，主要体现在单个节点修改的效率和内存占用上。</p>
<ul>
<li>优点：Map 结构存储的内容能够很快增删改某个特定节点，而对于树状数据结构，为了保证数据是持久化的 <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">Single source of truth</a>，必须按照不可变数据的理念（Immutable）去生成一个新对象，造成内存占用增大的问题。</li>
<li>缺点：相应地，由于存储 Map 的结构不能够很好地表达实际渲染出来 DOM 结果的层次，所以在每次渲染的时候，需要做一次协调（Reconcilation）去生成层次结构，<a href="https://github.com/facebook/lexical/blob/main/docs/design.md">可以把它想象成 React</a>，它通过双重缓存实现单向数据流渲染。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae64955afd1a4aa8beb5fb4e40f0d9c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>选区 Selection</h2>
<h4>ProseMirror</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ebb9befd7d4af59dbf5ac8782c1c1a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>定义：<a href="https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/selection.js"><code>src/edit/selection.js</code></a></p>
<p>ProseMirror 通过 <code>poll</code>的方式确定选区，也即轮询。每隔 100ms 就会对当前光标位置进行一次轮询，调用 <code>readFromDOM()</code> 从 DOM 读取真实选区并设置到编辑器实例的<code>sel</code>属性中。</p>
<p>通过 <code>window.getSeleciton()</code> 获取的真实选区会被转化成 <code>TextSelection</code> 并存储在 <code>sel.range</code> 中。此外还存储了上一次的真实选区在 <code>sel</code> 中，目的是用来比较判断 DOM 选区是否发生了变化。若没有发生变化，则不需要执行 <code>readFromDOM()</code>。</p>
<p>PS: 因为轮询更新选区的特性，在 demo 中快速输入中文时出现了光标的跑到行尾的问题。</p>
<h4>Slate</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daadeb4c8278435ab4b3ebfd2ba8e1b0~tplv-k3u1fbpfcp-zoom-1.image" alt="slate_selection"></p>
<p>定义：<a href="https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/interfaces/editor.ts"><code>packages/slate/src/interfaces/editor.ts</code></a></p>
<p>Slate 的选区是原生浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection"><code>Selection</code></a> 之上的一层抽象，形如：</p>
<pre><code>type Path = number[]
interface Point {
  path: Path
  offset: number
}
interface Range {
  anchor: Point
  focus: Point
}
interface Selection = Range | null
</code></pre>
<p>Slate 强大的地方在于它将 DOM 渲染出来的节点的可选区域抽象成 <code>Path</code>、<code>Point</code>、<code>Range</code> 等数据结构，一旦理解了它的设计逻辑，就能够很方便地定位到编辑器内某一个特定的范围，从而轻松实现插入、删除、移动等节点变换操作。</p>
<h4>Lexical</h4>
<p>Lexical 的选区包含 <code>anchor</code> 和 <code>focus</code> 两个点，并且在每个 <code>Point</code> 中存储了一份对当前 <code>_seletion</code> 的引用（循环引用）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/439f9908800245a1bd452ce70497f814~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>定义：<a href="https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical/src/LexicalSelection.ts"><code>packages/lexical/src/LexicalSelection.ts</code></a></p>
<h2>规范化处理</h2>
<p>规范化（Normalize）处理决定了一个编辑器的形状是否稳定。剪贴板中的 HTML 千奇百怪、不可预测，在富文本编辑器中粘贴时，未知的 HTML 处理起来十分棘手。兜底的方法是将 HTML 转成纯文本，但是这样就显得不够“富文本”了。</p>
<h4>ProseMirror</h4>
<p>采用了 Schema 定义文档的形状：<code>SchemaSpec</code> 类定义文档支持的 <code>marks</code> 和 <code>nodes</code>，<code>Schema</code> 类接收 <code>SchemaSpec</code> 为参数，并定义文章的形状。</p>
<p><code>SchemaItem</code> 是所有的 <code>NodeType</code> 的父类，也就是说，所有的元素都继承了 <code>SchemaItem.register()</code> 方法用于注册各元素的规则。并且是根据事件进行触发，对所有继承了 <code>SchemaItem</code> 类的元素节点进行 <code>register</code> 注册相应命名空间 <code>namespace</code> 的某个类型的 <code>name</code> ，并指明对应要做的操作，这样就能够在不同的处理步骤（如解析 DOM 节点）中对各个节点进行特定的处理。</p>
<h4>Slate</h4>
<p>Slate 在早期（v0.47 前）使用了和 ProseMirror 一样采用了 <code>Schema</code> 的形式，用 JS 模板对象限定了不同类型的操作。但是 v0.50 后 Slate 将组件进行了插件化拆分，每个组件都作为一个插件有一套独立的处理逻辑，通过组件插件的 <code>normalizeNode</code> 可以对组件进行修剪等处理操作。</p>
<h4>Lexical</h4>
<p>Lexical 采用的规范化处理方式包括 <code>_htmlConversions</code> （负责剪贴板内容的粘贴）、<code>LexicalUpdates</code> （负责合并同类型文本节点）等。</p>
<p>后者的 <code>Update</code> 是 Lexical 中定时处理步骤，每当 <code>editor._observer</code> （即 MutationObserver）监听到 DOM 节点发生变化，就会批量更新对应的虚拟节点，实现数据的同步。在 <code>Update</code> 的过程中，就会对编辑器内容进行规范化操作。</p>
<h2>原子操作</h2>
<p>这三款编辑器都支持使用 <a href="https://github.com/yjs/yjs">Yjs</a> 实现协同编辑，底层满足 <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDT</a> 的数据结构模型，ProseMirror 和 Slate 均是<strong>基于操作</strong>实现 CRDT 的，而 Lexical 则是<strong>基于状态</strong>实现 CRDT 的。</p>
<h4>ProseMirror</h4>
<p>ProseMirror 中操作变化都被当作 Operation 存储起来，在每个 <code>requestAnimationFrame</code> （宏任务）的循环中通过 <code>pm.flush</code> 被批量调用。</p>
<p>Operation 决定了更新 DOM 的最少步骤，存储在 <code>pm.operation</code> 中。</p>
<p>定义：<a href="https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/main.js"><code>src/edit/main.js</code></a></p>
<pre><code>class Operation {
  constructor(pm) {
    this.doc = pm.doc
    this.sel = pm.sel.range
    this.scrollIntoView = false
    this.focus = false
    this.composingAtStart = !!pm.input.composing
  }
}
</code></pre>
<h4>Slate</h4>
<p>Slate 是基于 Operation 的操作的。每个原子操作都通过了 <code>editor.apply</code> 去执行，实现上和 ProseMirror 类似，不过是通过 <code>Promise.resolve()</code> （微任务）的循环中通过 <code>editor.onChange()</code> 被批量调用。</p>
<p>定义：<a href="https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/transforms/general.ts"><code>packages/slate/src/transforms/general.ts</code></a></p>
<p>Operation 的种类包括：<code>insert_text</code>、<code>remove_text</code>、<code>insert_node</code>、<code>merge_node</code>、 <code>remove_node</code>、<code>move_node</code>、<code>set_node</code>、<code>split_node</code>。</p>
<p>详见： <a href="https://juejin.cn/post/7034480408888770567">Slate.js 之 Operation 概述</a></p>
<h4>Lexical</h4>
<p>Lexical 中存储的数据结构是散列表映射，因此对于这个数据结构来说，只需要进行映射记录之间的更新即可让数据实现同步。</p>
<p>Lexical 中使用了 <a href="https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical-yjs/src/CollabElementNode.ts"><code>CollabElementNode</code></a> 作为共享数据类型的存储，通过 <code>$createCollabNodeFromLexicalNode()</code> 函数将普通的节点转化为共享数据类型节点，该节点上会挂载一个实现了 <a href="https://docs.yjs.dev/api/shared-types/y.map"><code>Y.Map</code></a> 类的 <code>_map</code> 的属性。</p>
<h2>总结</h2>
<p>本文通过对比不同富文本编辑器框架的一些实现，分析了编辑器实例、选区、规范化、原子操作等。</p>
<ul>
<li>
<p>ProseMirror 登场比较早，<a href="https://prosemirror.net/docs/guide/">使用文档</a>详尽，插件丰富，功能强大，但是 API 略显晦涩。</p>
</li>
<li>
<p>Slate 最受欢迎（star 数领先），支持纯 JS 对象作为文档结构、个性化组件、丰富的 API、上手成本低，是很多编辑器的灵感来源，如语雀、Aomao。</p>
</li>
<li>
<p>Lexical 新兴力量，背靠 Facebook，映射结构、可以基于状态实现协同。<a href="https://discuss.prosemirror.net/t/choosing-between-prosemirror-and-slate/1596">此外</a>，它的 DOM 节点不受外部插件影响以及原生支持 React 18+ 的 Cocurrency 实现局部渲染性能优化。</p>
</li>
</ul>
<p>以上三者均未实现 1.0 的突破，未能保证稳定，使用时还需要进行一些额外的开发。</p>
</div><hr class="hr-fade-content" data-content="&lt;/ 富文本编辑器框架 ProseMirror、Slate 和 Lexical 横向比较 &gt;"/></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"富文本编辑器框架 ProseMirror、Slate 和 Lexical 横向比较","date":"2022-09-08","slug":"prosemirror-vs-slate-vs-lexical","content":"\u003ch2\u003e富文本编辑器的实现\u003c/h2\u003e\n\u003cp\u003e通常使用 \u003ca href=\"https://static001.geekbang.org/con/44/pdf/3673881710/file/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B-%E7%BD%97%E9%BE%99%E6%B5%A9.pdf\"\u003eL1\u003c/a\u003e 方案的富文本编辑器都是基于浏览器自身 \u003ccode\u003econtentEditable\u003c/code\u003e 属性实现的，共用了浏览器的光标和选区；对数据层进行了抽象，依赖 DOM 对内容进行渲染。\u003c/p\u003e\n\u003cp\u003eL1 富文本编辑器的重点在于实现视图层和数据层的双向绑定，确保视图层的改动。\u003c/p\u003e\n\u003cp\u003e本文将对以下三个的 L1 富文本编辑器进行横向比较。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ProseMirror/prosemirror\"\u003eProseMirror\u003c/a\u003e @0.6.0\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ianstormtaylor/slate\"\u003eSlate\u003c/a\u003e @v0.60.17\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/facebook/lexical\"\u003eLexical\u003c/a\u003e @0.3.11\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e三者对于视图层绑定到数据层的实现各不一样。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProseMirror 通过 JS 的原生 DOM 操作做了一层封装实现渲染。\u003c/li\u003e\n\u003cli\u003eSlate 通过插件化管理，将所有功能抽象成插件，不限定渲染框架。官方给出的是 \u003ccode\u003eslate-react\u003c/code\u003e 进行渲染，但是也可以用 \u003ca href=\"https://github.com/worktile/slate-angular\"\u003eAngular\u003c/a\u003e、\u003ca href=\"https://github.com/marsprince/slate-vue\"\u003eVue\u003c/a\u003e 等前端框架实现视图层的渲染。\u003c/li\u003e\n\u003cli\u003eLexical 同 Slate 也使用了插件化。官方通过 \u003ccode\u003elexical-react\u003c/code\u003e 进行渲染，但是并\u003ca href=\"https://github.com/facebook/lexical/blob/main/docs/design.md\"\u003e不拘泥于特定框架\u003c/a\u003e实现视图层。由于 Lexical 的数据结构是 Map 映射集合而不是普通对象，在渲染时需要先使用 \u003ca href=\"\"\u003e\u003ccode\u003ereconcileNode()\u003c/code\u003e\u003c/a\u003e 这个方法进行节点映射集合的遍历。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e编辑器实例\u003c/h2\u003e\n\u003ch4\u003eProseMirror\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c091176b4ef4064a5ec9a36a6a82a01~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"PM instance\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/main.js\"\u003e\u003ccode\u003esrc/edit/main.js\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eProseMirror 编辑器实例，使用 class 实现，\u003ccode\u003epm.doc\u003c/code\u003e 代表文档的根 Node 节点，\u003ccode\u003epm.sel\u003c/code\u003e代表文档的当前选区。\u003c/p\u003e\n\u003cp\u003eProseMirror 的文档节点可以分为三大类型，\u003ccode\u003eNode\u003c/code\u003e、\u003ccode\u003eFragment\u003c/code\u003e 和 \u003ccode\u003eMark\u003c/code\u003e，分别代表基本节点、基本节点数组和节点标记。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNode\u003c/code\u003e 可以拓展成为 \u003ccode\u003eTextNode\u003c/code\u003e，或者按照给定的 \u003ccode\u003eschema\u003c/code\u003e 拓展成为特定的 \u003ccode\u003eNodeType\u003c/code\u003e 进而用于代表段落、标题等。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFragment\u003c/code\u003e 类似一个容器，主要是将其 \u003ccode\u003econtent\u003c/code\u003e 属性中的基本节点数组包起来。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMark\u003c/code\u003e 类似一个占位符，用来表现某一个 \u003ccode\u003eTextNode\u003c/code\u003e 所含有的特征。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eSlate\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e62bc858758c4f83a2de7ffedd593eec~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Slate instance\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/create-editor.ts\"\u003e\u003ccode\u003epackages/slate/src/create-editor.ts\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSlate 的实例对象，与 ProseMirror 用类实现不同，Slate 采用了纯对象表示编辑器实例。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSlate 的早期也是基于 class 实现的，但是从 Immutable.js 切换到 Immer 的\u003ca href=\"https://github.com/ianstormtaylor/slate/issues/2345#issue-374819376\"\u003e重构\u003c/a\u003e后，转向了使用纯 JS 对象作为数据结构。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e该实例节点就是文档的根节点，可以从 \u003ccode\u003eeditor.children\u003c/code\u003e 获取到整个文档所有的子节点；\u003ccode\u003eeditor.selection\u003c/code\u003e 代表文档的当前选区。\u003c/p\u003e\n\u003ch4\u003eLexical\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d741b849fa4826af2e8f7fb8e1e190~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical/src/LexicalEditor.ts\"\u003e\u003ccode\u003epackages/lexical/src/LexicalEditor.ts\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLexical 编辑器实例，使用 class 实现，\u003ccode\u003eeditor._editorState._nodeMap\u003c/code\u003e 代表文档的节点合集，\u003ccode\u003eeditor._editorState._selection\u003c/code\u003e 代表文档的当前选区。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLexical 的独特之处\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLexical 的节点是通过 Map 存储的（如下图），这和 Slate、ProseMirror 的树状数据结构有本质差异，主要体现在单个节点修改的效率和内存占用上。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e优点：Map 结构存储的内容能够很快增删改某个特定节点，而对于树状数据结构，为了保证数据是持久化的 \u003ca href=\"https://en.wikipedia.org/wiki/Single_source_of_truth\"\u003eSingle source of truth\u003c/a\u003e，必须按照不可变数据的理念（Immutable）去生成一个新对象，造成内存占用增大的问题。\u003c/li\u003e\n\u003cli\u003e缺点：相应地，由于存储 Map 的结构不能够很好地表达实际渲染出来 DOM 结果的层次，所以在每次渲染的时候，需要做一次协调（Reconcilation）去生成层次结构，\u003ca href=\"https://github.com/facebook/lexical/blob/main/docs/design.md\"\u003e可以把它想象成 React\u003c/a\u003e，它通过双重缓存实现单向数据流渲染。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae64955afd1a4aa8beb5fb4e40f0d9c2~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e选区 Selection\u003c/h2\u003e\n\u003ch4\u003eProseMirror\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ebb9befd7d4af59dbf5ac8782c1c1a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/selection.js\"\u003e\u003ccode\u003esrc/edit/selection.js\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eProseMirror 通过 \u003ccode\u003epoll\u003c/code\u003e的方式确定选区，也即轮询。每隔 100ms 就会对当前光标位置进行一次轮询，调用 \u003ccode\u003ereadFromDOM()\u003c/code\u003e 从 DOM 读取真实选区并设置到编辑器实例的\u003ccode\u003esel\u003c/code\u003e属性中。\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ewindow.getSeleciton()\u003c/code\u003e 获取的真实选区会被转化成 \u003ccode\u003eTextSelection\u003c/code\u003e 并存储在 \u003ccode\u003esel.range\u003c/code\u003e 中。此外还存储了上一次的真实选区在 \u003ccode\u003esel\u003c/code\u003e 中，目的是用来比较判断 DOM 选区是否发生了变化。若没有发生变化，则不需要执行 \u003ccode\u003ereadFromDOM()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003ePS: 因为轮询更新选区的特性，在 demo 中快速输入中文时出现了光标的跑到行尾的问题。\u003c/p\u003e\n\u003ch4\u003eSlate\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daadeb4c8278435ab4b3ebfd2ba8e1b0~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"slate_selection\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/interfaces/editor.ts\"\u003e\u003ccode\u003epackages/slate/src/interfaces/editor.ts\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSlate 的选区是原生浏览器的 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Selection\"\u003e\u003ccode\u003eSelection\u003c/code\u003e\u003c/a\u003e 之上的一层抽象，形如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Path = number[]\ninterface Point {\n  path: Path\n  offset: number\n}\ninterface Range {\n  anchor: Point\n  focus: Point\n}\ninterface Selection = Range | null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSlate 强大的地方在于它将 DOM 渲染出来的节点的可选区域抽象成 \u003ccode\u003ePath\u003c/code\u003e、\u003ccode\u003ePoint\u003c/code\u003e、\u003ccode\u003eRange\u003c/code\u003e 等数据结构，一旦理解了它的设计逻辑，就能够很方便地定位到编辑器内某一个特定的范围，从而轻松实现插入、删除、移动等节点变换操作。\u003c/p\u003e\n\u003ch4\u003eLexical\u003c/h4\u003e\n\u003cp\u003eLexical 的选区包含 \u003ccode\u003eanchor\u003c/code\u003e 和 \u003ccode\u003efocus\u003c/code\u003e 两个点，并且在每个 \u003ccode\u003ePoint\u003c/code\u003e 中存储了一份对当前 \u003ccode\u003e_seletion\u003c/code\u003e 的引用（循环引用）。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/439f9908800245a1bd452ce70497f814~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical/src/LexicalSelection.ts\"\u003e\u003ccode\u003epackages/lexical/src/LexicalSelection.ts\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e规范化处理\u003c/h2\u003e\n\u003cp\u003e规范化（Normalize）处理决定了一个编辑器的形状是否稳定。剪贴板中的 HTML 千奇百怪、不可预测，在富文本编辑器中粘贴时，未知的 HTML 处理起来十分棘手。兜底的方法是将 HTML 转成纯文本，但是这样就显得不够“富文本”了。\u003c/p\u003e\n\u003ch4\u003eProseMirror\u003c/h4\u003e\n\u003cp\u003e采用了 Schema 定义文档的形状：\u003ccode\u003eSchemaSpec\u003c/code\u003e 类定义文档支持的 \u003ccode\u003emarks\u003c/code\u003e 和 \u003ccode\u003enodes\u003c/code\u003e，\u003ccode\u003eSchema\u003c/code\u003e 类接收 \u003ccode\u003eSchemaSpec\u003c/code\u003e 为参数，并定义文章的形状。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSchemaItem\u003c/code\u003e 是所有的 \u003ccode\u003eNodeType\u003c/code\u003e 的父类，也就是说，所有的元素都继承了 \u003ccode\u003eSchemaItem.register()\u003c/code\u003e 方法用于注册各元素的规则。并且是根据事件进行触发，对所有继承了 \u003ccode\u003eSchemaItem\u003c/code\u003e 类的元素节点进行 \u003ccode\u003eregister\u003c/code\u003e 注册相应命名空间 \u003ccode\u003enamespace\u003c/code\u003e 的某个类型的 \u003ccode\u003ename\u003c/code\u003e ，并指明对应要做的操作，这样就能够在不同的处理步骤（如解析 DOM 节点）中对各个节点进行特定的处理。\u003c/p\u003e\n\u003ch4\u003eSlate\u003c/h4\u003e\n\u003cp\u003eSlate 在早期（v0.47 前）使用了和 ProseMirror 一样采用了 \u003ccode\u003eSchema\u003c/code\u003e 的形式，用 JS 模板对象限定了不同类型的操作。但是 v0.50 后 Slate 将组件进行了插件化拆分，每个组件都作为一个插件有一套独立的处理逻辑，通过组件插件的 \u003ccode\u003enormalizeNode\u003c/code\u003e 可以对组件进行修剪等处理操作。\u003c/p\u003e\n\u003ch4\u003eLexical\u003c/h4\u003e\n\u003cp\u003eLexical 采用的规范化处理方式包括 \u003ccode\u003e_htmlConversions\u003c/code\u003e （负责剪贴板内容的粘贴）、\u003ccode\u003eLexicalUpdates\u003c/code\u003e （负责合并同类型文本节点）等。\u003c/p\u003e\n\u003cp\u003e后者的 \u003ccode\u003eUpdate\u003c/code\u003e 是 Lexical 中定时处理步骤，每当 \u003ccode\u003eeditor._observer\u003c/code\u003e （即 MutationObserver）监听到 DOM 节点发生变化，就会批量更新对应的虚拟节点，实现数据的同步。在 \u003ccode\u003eUpdate\u003c/code\u003e 的过程中，就会对编辑器内容进行规范化操作。\u003c/p\u003e\n\u003ch2\u003e原子操作\u003c/h2\u003e\n\u003cp\u003e这三款编辑器都支持使用 \u003ca href=\"https://github.com/yjs/yjs\"\u003eYjs\u003c/a\u003e 实现协同编辑，底层满足 \u003ca href=\"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type\"\u003eCRDT\u003c/a\u003e 的数据结构模型，ProseMirror 和 Slate 均是\u003cstrong\u003e基于操作\u003c/strong\u003e实现 CRDT 的，而 Lexical 则是\u003cstrong\u003e基于状态\u003c/strong\u003e实现 CRDT 的。\u003c/p\u003e\n\u003ch4\u003eProseMirror\u003c/h4\u003e\n\u003cp\u003eProseMirror 中操作变化都被当作 Operation 存储起来，在每个 \u003ccode\u003erequestAnimationFrame\u003c/code\u003e （宏任务）的循环中通过 \u003ccode\u003epm.flush\u003c/code\u003e 被批量调用。\u003c/p\u003e\n\u003cp\u003eOperation 决定了更新 DOM 的最少步骤，存储在 \u003ccode\u003epm.operation\u003c/code\u003e 中。\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ProseMirror/prosemirror/blob/0.10.1/src/edit/main.js\"\u003e\u003ccode\u003esrc/edit/main.js\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Operation {\n  constructor(pm) {\n    this.doc = pm.doc\n    this.sel = pm.sel.range\n    this.scrollIntoView = false\n    this.focus = false\n    this.composingAtStart = !!pm.input.composing\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eSlate\u003c/h4\u003e\n\u003cp\u003eSlate 是基于 Operation 的操作的。每个原子操作都通过了 \u003ccode\u003eeditor.apply\u003c/code\u003e 去执行，实现上和 ProseMirror 类似，不过是通过 \u003ccode\u003ePromise.resolve()\u003c/code\u003e （微任务）的循环中通过 \u003ccode\u003eeditor.onChange()\u003c/code\u003e 被批量调用。\u003c/p\u003e\n\u003cp\u003e定义：\u003ca href=\"https://github.com/ianstormtaylor/slate/blob/v0.61.3/packages/slate/src/transforms/general.ts\"\u003e\u003ccode\u003epackages/slate/src/transforms/general.ts\u003c/code\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eOperation 的种类包括：\u003ccode\u003einsert_text\u003c/code\u003e、\u003ccode\u003eremove_text\u003c/code\u003e、\u003ccode\u003einsert_node\u003c/code\u003e、\u003ccode\u003emerge_node\u003c/code\u003e、 \u003ccode\u003eremove_node\u003c/code\u003e、\u003ccode\u003emove_node\u003c/code\u003e、\u003ccode\u003eset_node\u003c/code\u003e、\u003ccode\u003esplit_node\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e详见： \u003ca href=\"https://juejin.cn/post/7034480408888770567\"\u003eSlate.js 之 Operation 概述\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003eLexical\u003c/h4\u003e\n\u003cp\u003eLexical 中存储的数据结构是散列表映射，因此对于这个数据结构来说，只需要进行映射记录之间的更新即可让数据实现同步。\u003c/p\u003e\n\u003cp\u003eLexical 中使用了 \u003ca href=\"https://github.com/facebook/lexical/blob/v0.4.0/packages/lexical-yjs/src/CollabElementNode.ts\"\u003e\u003ccode\u003eCollabElementNode\u003c/code\u003e\u003c/a\u003e 作为共享数据类型的存储，通过 \u003ccode\u003e$createCollabNodeFromLexicalNode()\u003c/code\u003e 函数将普通的节点转化为共享数据类型节点，该节点上会挂载一个实现了 \u003ca href=\"https://docs.yjs.dev/api/shared-types/y.map\"\u003e\u003ccode\u003eY.Map\u003c/code\u003e\u003c/a\u003e 类的 \u003ccode\u003e_map\u003c/code\u003e 的属性。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e本文通过对比不同富文本编辑器框架的一些实现，分析了编辑器实例、选区、规范化、原子操作等。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eProseMirror 登场比较早，\u003ca href=\"https://prosemirror.net/docs/guide/\"\u003e使用文档\u003c/a\u003e详尽，插件丰富，功能强大，但是 API 略显晦涩。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSlate 最受欢迎（star 数领先），支持纯 JS 对象作为文档结构、个性化组件、丰富的 API、上手成本低，是很多编辑器的灵感来源，如语雀、Aomao。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLexical 新兴力量，背靠 Facebook，映射结构、可以基于状态实现协同。\u003ca href=\"https://discuss.prosemirror.net/t/choosing-between-prosemirror-and-slate/1596\"\u003e此外\u003c/a\u003e，它的 DOM 节点不受外部插件影响以及原生支持 React 18+ 的 Cocurrency 实现局部渲染性能优化。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以上三者均未实现 1.0 的突破，未能保证稳定，使用时还需要进行一些额外的开发。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"prosemirror-vs-slate-vs-lexical"},"buildId":"vbjdjV-VpDLSvDSeVLm1q","assetPrefix":"https://pzij.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>