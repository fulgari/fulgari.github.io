<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="https://pzij.github.io/_next/static/css/40b8a65ab385b93c.css" as="style"/><link rel="stylesheet" href="https://pzij.github.io/_next/static/css/40b8a65ab385b93c.css" data-n-g=""/><link rel="preload" href="https://pzij.github.io/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="https://pzij.github.io/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://pzij.github.io/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pzij.github.io/_next/static/chunks/webpack-e09df0756682281e.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/framework-6e4ba497ae0c8a3f.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/main-101cfeaa18eb0e64.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/61-741c7743b5979a7a.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/964-e2167bad81babf73.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-2f09827022c6b085.js" defer=""></script><script src="https://pzij.github.io/_next/static/nSVNBde833HraJ-QTjpxD/_buildManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/nSVNBde833HraJ-QTjpxD/_ssgManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/nSVNBde833HraJ-QTjpxD/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container mx-auto px-[5vw] max-w-screen-xl"><div class="mb-32"><header class="flex justify-between items-center my-10 h-52 bg-no-repeat bg-center"><div class="logo ml-8 flex justify-start items-center cursor-pointer scale-110 transition-transform hover:scale-105"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2772%27%20height=%2772%27/%3e"/></span><img alt="Jun" href="/" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Jun" href="/" srcSet="https://pzij.github.io/qun.png 1x, https://pzij.github.io/qun.png 2x" src="https://pzij.github.io/qun.png" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span></div><ul class="list-none float-right mr-8"><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/">Home</span><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/about">About</span><span class="navbar-item mx-8 cursor-pointer text-gray-400 hover:text-black uppercase font-light" href="/contact">Contact</span></ul></header><title>内存控制<!-- --> | J.P.</title><h1 class="text-3xl flex justify-center items-center underline" style="text-decoration-color:#50c10c;margin-bottom:2em">内存控制</h1><div class="blog-post-container"><h1>内存控制</h1>
<p>谈及 Node，不得不谈它高明的内存控制。</p>
<h2>V8</h2>
<p>Node 的创始人 Ryan Dahl 很明智地选择了 google chrome 的成功之源，即性能卓越的 V8 引擎（事件驱动、非阻塞I/O）来作为 JavaScript 作为运行时虚拟机。</p>
<p>因为不论浏览器还是 Node，都是基于 V8 引擎的，而 JavaScript 对象所占内存都是通过 V8 来进行分配和管理的，因此只要基于 V8，不论是浏览器还是 Node，都使用同样的内存管理机制。</p>
<p>对前端 web 页面来说，64 位的机器可以使用约 1.4 GB 的内存，这已经够用了。而对于更大内存的对象，V8 无法直接处理，这就是 Node 需要解决的问题。</p>
<h2>对象分配</h2>
<p>一般对象都存放在<strong>堆内存</strong>中，而基本数据类型存放在栈内存中。</p>
<p>为什么 V8 不充分使用内存空间，而只使用有限内存呢？</p>
<p>这是因为受到 V8 的<strong>垃圾回收机制</strong>所限。</p>
<p>在垃圾回收过程中，会导致 JavaScript 线程的暂停执行。一次非增量式的垃圾回收甚至要一秒以上。</p>
<p>为了满足响应用户和提高性能，V8 选择直接限制堆内存大小。</p>
<h2>回收机制</h2>
<p>V8 的回收策略为<strong>分代式</strong>垃圾回收机制。</p>
<p>顾名思义，分代式回收会将堆内存分为新生代和老生代，前者存放存活时间较短的对象，后者则存放存活时间较长的对象。</p>
<p>在 64 位系统中，新生代大小为 32 MB，而老生代大小为 1464 MB。</p>
<p>对于新生代中的对象，有不少转瞬即逝的对象，使用 Scavenge 算法进行垃圾回收。</p>
<blockquote>
<p>Scavenge 算法: 复制存活的对象。将对象从 From 空间移动到 To 空间保留下来，来回往复。</p>
</blockquote>
<p>通常新生代内存中的对象经过 Scavenge 算法回收，能够通过<strong>晋升</strong>进入到老生代。</p>
<p>而老生代中的对象通常都存活较就，则使用 Mark-Sweep（主要） 和 Mark-Compact（内存不足时，对晋升的对象使用） 算法进行垃圾回收。</p>
<blockquote>
<p>Mark-Sweep 算法： 标记清除死亡对象。将没有使用的对象标记为死亡，并在垃圾回收中进行清除。
Mark-Compact 算法：标记清除死亡对象，并将存活对象移动到一端（不会产生内存碎片）。</p>
</blockquote>
</div><hr class="hr-fade-content" data-content="&lt;/ 内存控制 &gt;"/></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"内存控制","date":"2022-03-15","slug":"memory-control","content":"\u003ch1\u003e内存控制\u003c/h1\u003e\n\u003cp\u003e谈及 Node，不得不谈它高明的内存控制。\u003c/p\u003e\n\u003ch2\u003eV8\u003c/h2\u003e\n\u003cp\u003eNode 的创始人 Ryan Dahl 很明智地选择了 google chrome 的成功之源，即性能卓越的 V8 引擎（事件驱动、非阻塞I/O）来作为 JavaScript 作为运行时虚拟机。\u003c/p\u003e\n\u003cp\u003e因为不论浏览器还是 Node，都是基于 V8 引擎的，而 JavaScript 对象所占内存都是通过 V8 来进行分配和管理的，因此只要基于 V8，不论是浏览器还是 Node，都使用同样的内存管理机制。\u003c/p\u003e\n\u003cp\u003e对前端 web 页面来说，64 位的机器可以使用约 1.4 GB 的内存，这已经够用了。而对于更大内存的对象，V8 无法直接处理，这就是 Node 需要解决的问题。\u003c/p\u003e\n\u003ch2\u003e对象分配\u003c/h2\u003e\n\u003cp\u003e一般对象都存放在\u003cstrong\u003e堆内存\u003c/strong\u003e中，而基本数据类型存放在栈内存中。\u003c/p\u003e\n\u003cp\u003e为什么 V8 不充分使用内存空间，而只使用有限内存呢？\u003c/p\u003e\n\u003cp\u003e这是因为受到 V8 的\u003cstrong\u003e垃圾回收机制\u003c/strong\u003e所限。\u003c/p\u003e\n\u003cp\u003e在垃圾回收过程中，会导致 JavaScript 线程的暂停执行。一次非增量式的垃圾回收甚至要一秒以上。\u003c/p\u003e\n\u003cp\u003e为了满足响应用户和提高性能，V8 选择直接限制堆内存大小。\u003c/p\u003e\n\u003ch2\u003e回收机制\u003c/h2\u003e\n\u003cp\u003eV8 的回收策略为\u003cstrong\u003e分代式\u003c/strong\u003e垃圾回收机制。\u003c/p\u003e\n\u003cp\u003e顾名思义，分代式回收会将堆内存分为新生代和老生代，前者存放存活时间较短的对象，后者则存放存活时间较长的对象。\u003c/p\u003e\n\u003cp\u003e在 64 位系统中，新生代大小为 32 MB，而老生代大小为 1464 MB。\u003c/p\u003e\n\u003cp\u003e对于新生代中的对象，有不少转瞬即逝的对象，使用 Scavenge 算法进行垃圾回收。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eScavenge 算法: 复制存活的对象。将对象从 From 空间移动到 To 空间保留下来，来回往复。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e通常新生代内存中的对象经过 Scavenge 算法回收，能够通过\u003cstrong\u003e晋升\u003c/strong\u003e进入到老生代。\u003c/p\u003e\n\u003cp\u003e而老生代中的对象通常都存活较就，则使用 Mark-Sweep（主要） 和 Mark-Compact（内存不足时，对晋升的对象使用） 算法进行垃圾回收。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMark-Sweep 算法： 标记清除死亡对象。将没有使用的对象标记为死亡，并在垃圾回收中进行清除。\nMark-Compact 算法：标记清除死亡对象，并将存活对象移动到一端（不会产生内存碎片）。\u003c/p\u003e\n\u003c/blockquote\u003e\n"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"memory-control"},"buildId":"nSVNBde833HraJ-QTjpxD","assetPrefix":"https://pzij.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>