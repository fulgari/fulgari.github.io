<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="https://pzij.github.io/_next/static/css/5739fde43a8f7d26.css" as="style"/><link rel="stylesheet" href="https://pzij.github.io/_next/static/css/5739fde43a8f7d26.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="https://pzij.github.io/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pzij.github.io/_next/static/chunks/webpack-e09df0756682281e.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/framework-6e4ba497ae0c8a3f.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/main-101cfeaa18eb0e64.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/116-d766bdb6c362f982.js" defer=""></script><script src="https://pzij.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-792daabfc2b9a8c5.js" defer=""></script><script src="https://pzij.github.io/_next/static/7DGdGlyv-qusCTnoiLFwI/_buildManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/7DGdGlyv-qusCTnoiLFwI/_ssgManifest.js" defer=""></script><script src="https://pzij.github.io/_next/static/7DGdGlyv-qusCTnoiLFwI/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container mx-auto"><div class=""><header class="flex justify-between items-center my-10 h-52 bg-gradient-to-r from-gray-500 to-white-500 bg-no-repeat bg-center"><div class="logo"><a class="navbar-title font-serif cursor-pointer text-white ml-10 text-xl" href="/">Πάν</a></div><ul style="list-style:none;float:right;margin:0"><span class="navbar-item" style="margin:0 12px;cursor:pointer" href="/">Home</span><span class="navbar-item" style="margin:0 12px;cursor:pointer" href="/about">About</span><span class="navbar-item" style="margin:0 12px;cursor:pointer" href="/contact">Contact</span></ul></header><h1 class="text-3xl flex justify-center items-center underline" style="text-decoration-color:#43c37a">内存控制</h1><div class="blog-post-container"><h1>内存控制</h1>
<p>谈及 Node，不得不谈它高明的内存控制。</p>
<h2>V8</h2>
<p>Node 的创始人 Ryan Dahl 很明智地选择了 google chrome 的成功之源，即性能卓越的 V8 引擎（事件驱动、非阻塞I/O）来作为 JavaScript 作为运行时虚拟机。</p>
<p>因为不论浏览器还是 Node，都是基于 V8 引擎的，而 JavaScript 对象所占内存都是通过 V8 来进行分配和管理的，因此只要基于 V8，不论是浏览器还是 Node，都使用同样的内存管理机制。</p>
<p>对前端 web 页面来说，64 位的机器可以使用约 1.4 GB 的内存，这已经够用了。而对于更大内存的对象，V8 无法直接处理，这就是 Node 需要解决的问题。</p>
<h2>对象分配</h2>
<p>一般对象都存放在<strong>堆内存</strong>中，而基本数据类型存放在栈内存中。</p>
<p>为什么 V8 不充分使用内存空间，而只使用有限内存呢？</p>
<p>这是因为受到 V8 的<strong>垃圾回收机制</strong>所限。</p>
<p>在垃圾回收过程中，会导致 JavaScript 线程的暂停执行。一次非增量式的垃圾回收甚至要一秒以上。</p>
<p>为了满足响应用户和提高性能，V8 选择直接限制堆内存大小。</p>
<h2>回收机制</h2>
<p>V8 的回收策略为<strong>分代式</strong>垃圾回收机制。</p>
<p>顾名思义，分代式回收会将堆内存分为新生代和老生代，前者存放存活时间较短的对象，后者则存放存活时间较长的对象。</p>
<p>在 64 位系统中，新生代大小为 32 MB，而老生代大小为 1464 MB。</p>
<p>对于新生代中的对象，有不少转瞬即逝的对象，使用 Scavenge 算法进行垃圾回收。</p>
<blockquote>
<p>Scavenge 算法: 复制存活的对象。将对象从 From 空间移动到 To 空间保留下来，来回往复。</p>
</blockquote>
<p>通常新生代内存中的对象经过 Scavenge 算法回收，能够通过<strong>晋升</strong>进入到老生代。</p>
<p>而老生代中的对象通常都存活较就，则使用 Mark-Sweep（主要） 和 Mark-Compact（内存不足时，对晋升的对象使用） 算法进行垃圾回收。</p>
<blockquote>
<p>Mark-Sweep 算法： 标记清除死亡对象。将没有使用的对象标记为死亡，并在垃圾回收中进行清除。
Mark-Compact 算法：标记清除死亡对象，并将存活对象移动到一端（不会产生内存碎片）。</p>
</blockquote>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"内存控制","date":"2022-03-15","slug":"memory-control","content":"\u003ch1\u003e内存控制\u003c/h1\u003e\n\u003cp\u003e谈及 Node，不得不谈它高明的内存控制。\u003c/p\u003e\n\u003ch2\u003eV8\u003c/h2\u003e\n\u003cp\u003eNode 的创始人 Ryan Dahl 很明智地选择了 google chrome 的成功之源，即性能卓越的 V8 引擎（事件驱动、非阻塞I/O）来作为 JavaScript 作为运行时虚拟机。\u003c/p\u003e\n\u003cp\u003e因为不论浏览器还是 Node，都是基于 V8 引擎的，而 JavaScript 对象所占内存都是通过 V8 来进行分配和管理的，因此只要基于 V8，不论是浏览器还是 Node，都使用同样的内存管理机制。\u003c/p\u003e\n\u003cp\u003e对前端 web 页面来说，64 位的机器可以使用约 1.4 GB 的内存，这已经够用了。而对于更大内存的对象，V8 无法直接处理，这就是 Node 需要解决的问题。\u003c/p\u003e\n\u003ch2\u003e对象分配\u003c/h2\u003e\n\u003cp\u003e一般对象都存放在\u003cstrong\u003e堆内存\u003c/strong\u003e中，而基本数据类型存放在栈内存中。\u003c/p\u003e\n\u003cp\u003e为什么 V8 不充分使用内存空间，而只使用有限内存呢？\u003c/p\u003e\n\u003cp\u003e这是因为受到 V8 的\u003cstrong\u003e垃圾回收机制\u003c/strong\u003e所限。\u003c/p\u003e\n\u003cp\u003e在垃圾回收过程中，会导致 JavaScript 线程的暂停执行。一次非增量式的垃圾回收甚至要一秒以上。\u003c/p\u003e\n\u003cp\u003e为了满足响应用户和提高性能，V8 选择直接限制堆内存大小。\u003c/p\u003e\n\u003ch2\u003e回收机制\u003c/h2\u003e\n\u003cp\u003eV8 的回收策略为\u003cstrong\u003e分代式\u003c/strong\u003e垃圾回收机制。\u003c/p\u003e\n\u003cp\u003e顾名思义，分代式回收会将堆内存分为新生代和老生代，前者存放存活时间较短的对象，后者则存放存活时间较长的对象。\u003c/p\u003e\n\u003cp\u003e在 64 位系统中，新生代大小为 32 MB，而老生代大小为 1464 MB。\u003c/p\u003e\n\u003cp\u003e对于新生代中的对象，有不少转瞬即逝的对象，使用 Scavenge 算法进行垃圾回收。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eScavenge 算法: 复制存活的对象。将对象从 From 空间移动到 To 空间保留下来，来回往复。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e通常新生代内存中的对象经过 Scavenge 算法回收，能够通过\u003cstrong\u003e晋升\u003c/strong\u003e进入到老生代。\u003c/p\u003e\n\u003cp\u003e而老生代中的对象通常都存活较就，则使用 Mark-Sweep（主要） 和 Mark-Compact（内存不足时，对晋升的对象使用） 算法进行垃圾回收。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMark-Sweep 算法： 标记清除死亡对象。将没有使用的对象标记为死亡，并在垃圾回收中进行清除。\nMark-Compact 算法：标记清除死亡对象，并将存活对象移动到一端（不会产生内存碎片）。\u003c/p\u003e\n\u003c/blockquote\u003e\n"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"memory-control"},"buildId":"7DGdGlyv-qusCTnoiLFwI","assetPrefix":"https://pzij.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>