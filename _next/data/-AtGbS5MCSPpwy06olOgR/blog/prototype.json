{"pageProps":{"post":{"title":"原型链","date":"2022-06-26","slug":"prototype","content":"<h1>原型链</h1>\n<p>首先, 看下 Bublé 的继承是怎么实现的.</p>\n<blockquote>\n<p>cf: <a href=\"https://buble.surge.sh/\">Bublé</a></p>\n</blockquote>\n<pre><code>function Gender() {\n  console.log(\"Gender-0\", arguments.callee, this);\n}\n\n// ES6\nclass Male extends Gender {\n  constructor(age) {\n    super();\n    this.age = age;\n  }\n  getAge() {\n    return this.age;\n  }\n}\n\n// ES5\nvar Female = (function (Gender) {\n  function Female(age) {\n    // [盗用]: 子类盗用父类的构造函数 (Constructor stealing) _获取实例属性_\n    Gender.call(this);\n    this.age = age;\n  }\n  if (Gender) {\n    // 这个 `__proto__` 无对应中文译名, 我愿称之为 \"子宫 (=指共) 指针\". 能让实例获取共有属性.\n    Female.__proto__ = Gender;\n  }\n  // [原型]: 子类的 `prototype` 配置为父类的原型对象之副本 (采用 new 对象或 create 对象的方式) _获取原型属性_\n  // [寄生]: (1)用 `Object.create(Gender.prototype)` 代替 `new Gender()` (2)补充上新原型对象的 `constructor` 以弥补构造器的缺失. 从而避免两次调用父类的构造函数\n  // [组合]: 同时使用 [盗用] 及 [原型]\n  Female.prototype = Object.create(Gender &#x26;&#x26; Gender.prototype);\n  Female.prototype.constructor = Female;\n  Female.prototype.getAge = function () {\n    return this.age;\n  };\n  return Female;\n})(Gender);\n\nconst gender = new Gender(1);\nconst male = new Male(12);\nconst female = new Female(22);\n\nconsole.log(\"[out]\", gender, male, female, male.getAge(), female.getAge());\nconsole.log(\n  \"[typeof]\",\n  typeof gender,\n  typeof male.__proto__,\n  typeof male.prototype,\n  typeof Male.prototype,\n  typeof Male\n);\n</code></pre>\n<p>输出以下结果：</p>\n<pre><code>Gender-0 [Function: Gender] Gender {}\nGender-0 [Function: Gender] Male {}\nGender-0 [Function: Gender] Female {}\n[out] Gender {} Male { age: 12 } Female { age: 22 } 12 22\n[typeof] object object undefined object function\n</code></pre>\n<blockquote>\n<p>上述 [盗用], [原型], [寄生], [组合] 都能够看作是某种实现继承的哲学.</p>\n</blockquote>\n<p><code>class extends</code> 使用的是寄生组合继承.</p>\n<p>继承本质上是一种 OOP 概念, 我们想要达到的目的无非就是逻辑复用. 由于 JavaScript 的弱类型语言特性, 所以继承的实现方式也比较灵活. 可以\"不知廉耻\"地盗用父类构造函数创造自己的类, 也可以造一个和父类原型对象一样的对象, 并拓展该对象以创造自己的类.</p>\n<p><code>__proto__</code> 还没有中文对照, 但是我觉得称它为 \"子宫指针\" 是一个很好的记忆点. 因为它: (1) 是一个存在于实例上的属性, 指向创建构造它的函数的原型对象 (感觉就像是指向孕育自己的子宫) (2) 因为它也是获取原型链上共有属性 (非实例属性) 的一个桥梁, 即指向共有属性所在原型链的指针, \"指共\" 谐音 \"子宫\".</p>\n<blockquote>\n<p>以上谈到的 <em>类</em>, <em>原型对象</em>, <em>子宫指针</em> 都是 <code>object</code></p>\n</blockquote>\n"}},"__N_SSG":true}