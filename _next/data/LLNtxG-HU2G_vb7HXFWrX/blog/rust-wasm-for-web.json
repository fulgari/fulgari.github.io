{"pageProps":{"post":{"title":"手把手教学，使用 Rust + WASM 进行 Web 开发","date":"2022-10-20","slug":"rust-wasm-for-web","content":"<h2>背景</h2>\n<p>WebAssembly（WASM）是一个简单的机器模型和可执行格式，具有广泛的规范。它被设计为便携、紧凑，代码执行能够达到接近本机原生指令的执行速度。</p>\n<p>作为一种编程语言，WebAssembly 由两种格式组成，它们以不同的方式表示相同的结构：</p>\n<ul>\n<li>后缀为 <code>.wat</code> 的文本格式（称为“WebAssembly Text”），可以被人类理解，使用 <a href=\"https://zh.wikipedia.org/wiki/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F\">S-表达式</a>。</li>\n<li>后缀为 <code>.wasm</code> 的二进制格式是较低级别的，人无法读懂，它旨在供 wasm 虚拟机直接使用。</li>\n</ul>\n<p>作为参考，下面是一个在 JS 中调用两数求和 WASM 函数的例子：</p>\n<pre><code>const wasmInstance = new WebAssembly.Instance(wasmModule, {});\r\nconst { addTwo } = wasmInstance.exports;\r\nfor (let i = 0; i &#x3C; 5; i++) {\r\n  console.log(addTwo(i, i));\r\n}\r\n/**\r\n * output:\r\n * 0\r\n * 2\r\n * 4\r\n * 6\r\n * 8\r\n **/\n</code></pre>\n<p><code>addTwo</code> 函数本身是由其他语言编写而成的，并且被编译成了 <code>.wat</code> 格式。以下是这个 <code>addTwo</code> 求和函数的 <code>.wat</code> 文件：</p>\n<pre><code>(module\r\n  (func (export \"addTwo\") (param i32 i32) (result i32)\r\n    local.get 0\r\n    local.get 1\r\n    i32.add))\n</code></pre>\n<blockquote>\n<p>可以通过这个网站将 <code>.wat</code> 生成对应的二进制 <code>.wasm</code> 文件：<a href=\"https://webassembly.github.io/wabt/demo/wat2wasm/\">wat2wasm demo</a></p>\n</blockquote>\n<h2>环境配置</h2>\n<ol>\n<li>安装 <a href=\"https://www.rust-lang.org/tools/install\">rust 工具链</a>（<code>rustup</code>，<code>rustc</code>，<code>cargo</code>）</li>\n<li>安装 <a href=\"https://rustwasm.github.io/wasm-pack/installer/\">wasm-pack</a>，一个构建、测试和发布 WASM 的 Rust CLI 工具，我们将使用 <code>wasm-pack</code> 相关的命令来构建 WASM 二进制内容。</li>\n<li>npm，JS 包管理器</li>\n</ol>\n<p>如果不安装 wasm-pack，使用打包工具 <code>webpack</code> 加上 <code>@wasm-tool/wasm-pack-plugin</code> 插件也能构建 WASM，后文会详细介绍。</p>\n<blockquote>\n<p>Tips：安装 <a href=\"https://github.com/cargo-generate/cargo-generate\">cargo-generate</a>，能够使用现有的 git 仓库生成一个新的 Rust 项目： <code>cargo install cargo-generate</code></p>\n</blockquote>\n<h2>快速入门</h2>\n<h3>项目初始化</h3>\n<p>首先我们执行 <code>cargo new wasm-demo</code> 初始化 Rust 项目，新建一个名为 <code>wasm-demo</code> 的文件夹（也可以选一个你喜欢的文件夹名），自动生成配置文件 <code>Cargo.toml</code>，结构如下。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c6527aa05242f89cf3e6b63bd1f8d2~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h3>配置包文件</h3>\n<p>我们可以在 <code>Cargo.toml</code> 文件中加上下列代码并保存，保存之后 Cargo 会自动下载依赖。</p>\n<ul>\n<li><code>cdylib</code> 用来指明库的类型。</li>\n<li><code>wasm-bindgen</code> 是一个简化 Rust WASM 与 JS 之间交互的库。\n<ul>\n<li>它能够将如 DOM 操作、console.log 和 performance 等 JS 相关 API 暴露给 Rust 使用</li>\n<li>它能够将 Rust 功能导出到 JS 中，如类、函数等</li>\n</ul>\n</li>\n</ul>\n<pre><code>[lib]\r\ncrate-type = [\"cdylib\"]\r\n\r\n[dependencies]\r\nwasm-bindgen = \"0.2.83\"\n</code></pre>\n<h3>编写代码</h3>\n<p>接着开始编写一些简单的 Rust 代码。将模板文件中的 <code>src/main.rs</code> 改成 <code>src/lib.rs</code>，里面写上一个求斐波那契数列的 Rust 函数。需要加上<code>#[wasm_bindgen]</code>标注告诉 wasm-pack 需要将这个函数编译成 wasm 可执行文件。</p>\n<pre><code>use wasm_bindgen::prelude::*; // 用于加载 Prelude（预导入）模块\r\n\r\n#[wasm_bindgen]\r\npub fn fib(n: u32) -> u32 {\r\n    if n == 0 || n == 1 {\r\n        return 1;\r\n    }\r\n    fib(n - 1) + fib(n - 2)\r\n}\r\n\n</code></pre>\n<p>当前目录应该长这样：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f303627174104ca09db1fb7caa420487~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>Rust 中包管理系统将 crate 包分为二进制包（Binary）和库包（Library）两种，二者可以在同一个项目中<a href=\"https://dev.to/yjdoc2/make-a-combined-library-and-binary-project-in-rust-d4f\">同时存在</a>。</p>\n<p>二进制包：</p>\n<ul>\n<li><code>main.rs</code> 是二进制项目的入口</li>\n<li>二进制项目可直接执行</li>\n<li>一个项目中二进制包可以有多个，所以在 Cargo.toml 中通过双方括号标识 <code>[[bin]]</code></li>\n</ul>\n<p>库包：</p>\n<ul>\n<li><code>lib.rs</code> 是库包的入口。</li>\n<li>库项目不可直接执行，通常用来作为一个模块被其他项目引用。</li>\n<li>一个项目中库包仅有 1 个，在 Cargo.toml 中通过单方括号标识 <code>[lib]</code></li>\n</ul>\n<p>因为我们这里希望将 WASM 转为一个可以在 JS 项目中使用的模块，所以需要使用库包 <code>lib.rs</code> 的命名。</p>\n<h3>执行编译</h3>\n<p>只需要执行我们之前安装的 wasm-pack 即可将刚刚的 Rust 代码转换成能够被 JS 导入的模块。</p>\n<pre><code>wasm-pack build\n</code></pre>\n<p>编译完成后，我们会发现根目录下多了一个 <code>pkg/</code> 文件夹，里面就是我们的 WASM 产物所在的 npm 包了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3269892162f3491b94d0e2715f491875~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>包的入口文件是不带 <code>_bg</code> 的 <code>.js</code> 文件，即 <code>wasm_demo2.js</code>。</p>\n<p><code>wasm_demo2.js</code> 的内容如下：</p>\n<pre><code>import * as wasm from \"./wasm_demo2_bg.wasm\";\r\nexport * from \"./wasm_demo2_bg.js\";\n</code></pre>\n<p><code>wasm_demo2_bg.js</code> 的内容如下：</p>\n<pre><code>import * as wasm from './wasm_demo2_bg.wasm';\r\n\r\n/**\r\n* @param {number} n\r\n* @returns {number}\r\n*/\r\nexport function fib(n) {\r\n    const ret = wasm.fib(n);\r\n    return ret >>> 0;\r\n}\n</code></pre>\n<p><code>wasm_demo2.d.ts</code> 的内容如下：</p>\n<pre><code>/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n* @param {number} n\r\n* @returns {number}\r\n*/\r\nexport function fib(n: number): number;\r\n\n</code></pre>\n<blockquote>\n<p>可以看到，wasm-pack 打包不仅输出一个 ESM 规范的模块，而且还支持自动生成 d.ts 文件，对模块的使用者非常友好。</p>\n</blockquote>\n<h3>使用 WASM 包</h3>\n<p>下面我们就新建一个 html 页面去调用刚刚生成的模块。在根目录下生成 <code>index.html</code>，并输入以下内容。</p>\n<pre><code>&#x3C;!DOCTYPE html>\r\n&#x3C;html lang=\"en\">\r\n&#x3C;head>\r\n    &#x3C;meta charset=\"UTF-8\">\r\n    &#x3C;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    &#x3C;title>Rust WASM demo&#x3C;/title>\r\n    &#x3C;script>\r\n        /**\r\n         * 1. 通过使用 instantiateStreaming 调用流式实例化\r\n         **/\r\n        WebAssembly.instantiateStreaming(fetch(\"./pkg/wasm_demo2.wasm\")).then((obj) => {\r\n            const fib = obj.instance.exports.fib;\r\n            const out = fib(20);\r\n            console.log(\"rust output: \", out);\r\n        })\r\n        \r\n        /**\r\n         * 2. 不通过流式调用，直接读取二进制文件并对字节进行实例化\r\n         **/\r\n        fetch(\"./pkg/wasm_demo2.wasm\")\r\n        .then(res => res.arrayBuffer())\r\n        .then(bytes => WebAssembly.instantiate(bytes))\r\n        .then(results => {\r\n            const fib = results.instance.exports.fib;\r\n            const out = fib(20);\r\n            console.log(\"rust output: \", out);\r\n        })\r\n\r\n    &#x3C;/script>\r\n&#x3C;/head>\r\n&#x3C;body>\r\n    \r\n&#x3C;/body>\r\n&#x3C;/html>\n</code></pre>\n<p>如上所示，可以通过流式与非流式两种原生 JS API 方式进行 <code>.wasm</code> 二进制文件的模块实例化。</p>\n<p>接下来编写一个简单的服务 <code>server.js</code>：</p>\n<pre><code>const http = require('http');\r\nconst fs = require('fs');\r\n\r\nconst reqListener = function(req, res) {\r\n    f = req.url === '/' ? 'index.html' : './pkg/wasm_demo2_bg.wasm';\r\n    if (f === './pkg/wasm_demo2_bg.wasm') {\r\n        res.setHeader('Content-type', 'application/wasm')\r\n      }\r\n      res.writeHead(200)\r\n      return fs.createReadStream(f).pipe(res)\r\n}\r\n\r\nconst server = http.createServer(reqListener);\r\nserver.listen(8081);\r\nconsole.log('listening: http://localhost:8081')\n</code></pre>\n<p>开启服务：</p>\n<pre><code>node server.js\n</code></pre>\n<p>打开 html 页面 <a href=\"http://localhost:8081/\">http://localhost:8081/</a> ，在控制台可看到两份 <code>fib(20)</code> 的结果被打印出来了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d2f43d4d034ba7b0cd60e2307463ed~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h2>进阶用法</h2>\n<h3>配合 Webpack 使用</h3>\n<p>使用 Webpack + wasm-pack 插件的方式构建和测试，可以直接通过 npm scripts 运行代码，像前端开发一样调试。</p>\n<p>用 <code>npm init -y</code> 新建一个项目，在 <code>package.json</code> 中新增如下代码：</p>\n<pre><code>...\r\n  \"scripts\": {\r\n    \"build\": \"webpack\",\r\n    \"serve\": \"webpack serve\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@wasm-tool/wasm-pack-plugin\": \"1.5.0\",\r\n    \"html-webpack-plugin\": \"^5.3.2\",\r\n    \"text-encoding\": \"^0.7.0\",\r\n    \"webpack\": \"^5.49.0\",\r\n    \"webpack-cli\": \"^4.7.2\",\r\n    \"webpack-dev-server\": \"^3.11.2\"\r\n  },\r\n  ...\n</code></pre>\n<p>执行 <code>npm i</code> 安装依赖。</p>\n<p>新建 <code>index.js</code> 文件，作为 WASM 模块的执行文件。在里面写入如下内容：</p>\n<pre><code>// 因为 webpack 的 bug（webpack/webpack#6615），这里暂时只能使用动态导入 import\r\nconst rust = import('./pkg');\r\n\r\nrust.then(m => {\r\n    const out = m.fib(20);\r\n    console.log(\"rust output: \", out);\r\n}).catch(console.error)\n</code></pre>\n<p>新建 <code>webpack.config.js</code> 文件，并进行如下配置：</p>\n<pre><code>const path = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst webpack = require('webpack');\r\nconst WasmPackPlugin = require(\"@wasm-tool/wasm-pack-plugin\"); // 赋予 webpack 处理 wasm 能力的插件\r\n\r\n/**\r\n * @type import('webpack').Configuration\r\n */\r\nmodule.exports = {\r\n    entry: './index.js',\r\n    devServer: {\r\n        port: '8082'\r\n    },\r\n    output: {\r\n        path: path.resolve(__dirname, 'dist'),\r\n        filename: 'index.js',\r\n    },\r\n    plugins: [\r\n        new HtmlWebpackPlugin(),\r\n        new WasmPackPlugin({\r\n            crateDirectory: path.resolve(__dirname, \".\")\r\n        }),\r\n        // Have this example work in Edge which doesn't ship `TextEncoder` or\r\n        // `TextDecoder` at this time. 处理浏览器兼容问题\r\n        new webpack.ProvidePlugin({\r\n          TextDecoder: ['text-encoding', 'TextDecoder'],\r\n          TextEncoder: ['text-encoding', 'TextEncoder']\r\n        })\r\n    ],\r\n    mode: 'development',\r\n    experiments: {\r\n        asyncWebAssembly: true // 打开异步 WASM 功能\r\n   }\r\n};\n</code></pre>\n<p>执行 <code>npm run build</code> 构建出 WASM 二进制产物。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac188d2836145829682f962c84429c4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>执行 <code>npm run serve</code> 即可进行开发，在浏览器的控制台中实时看到对应 <code>fib(20)</code> 的结果。我们可以在 <code>index.js</code> 中更改传入的参数，并查看控制台的新输出结果。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c74f7c5cff4661b55104ba0982fc5a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>总结就是，使用 webpack 能够帮助能够更加高效地进行 Rust WASM 应用的开发和调试。</p>\n<p>这一块借助了 webpack-dev-server 的 HMR 模块实现热更新：</p>\n<ol>\n<li>打包时将一块 webpack 脚本代码（JSONP 脚本）打包到客户端应用中。</li>\n<li>当本地 <code>lib.rs</code> 文件发生变化时，服务端 webpack-dev-server 通过 websocket 通知客户端应用代码中的 webpack 脚本代码，客户端向服务端请求最新编译好的 wasm 模块</li>\n<li>新的 WASM 模块以 JSONP 的方式从服务端传输到客户端</li>\n<li>通过 webpack 重写的 <code>__webpack_require__</code> 方法获取到新模块并加载、包裹、运行和缓存，实现模块的热替换。</li>\n</ol>\n<h3>Rust 操纵 DOM</h3>\n<p>实现一个求斐波那契数的应用，如下所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8401845ba8424b8d806a3cf34e0923a3~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>需要先安装一个叫 <code>web-sys</code> 的 Crate，它为 Rust 提供了控制 DOM 的能力，在 <code>Cargo.toml</code> 中新增依赖：</p>\n<pre><code>[dependencies.web-sys]\r\nversion = \"0.3.4\"\r\nfeatures = [ 'Document', 'Element', 'HtmlElement', 'Node', 'Window', 'HtmlInputElement']\n</code></pre>\n<blockquote>\n<p><code>features</code> 需要开发者手动地声明需要使用到的模块，这样做的好处有二：一是避免不同模块下的 <code>features</code> 名字发生冲突；二是条件编译各个依赖中的特性，对不使用的 <code>features</code> 不编译。</p>\n</blockquote>\n<p>在 <code>lib.rs</code> 函数中新增 <code>init()</code> 函数，用于生成 DOM 节点、挂载监听器并挂载 DOM 节点。</p>\n<pre><code>\r\n// start 标识 init() 在 WASM 加载时自动执行\r\n#[wasm_bindgen(start)]\r\npub fn init() -> Result&#x3C;(), JsValue> {\r\n    // 使用 web_sys 的 window 全局对象\r\n    let window = web_sys::window().expect(\"不存在全局 window 对象\");\r\n    let document = window.document().expect(\"需要在 window 上存在 document\");\r\n    let body = document.body().expect(\"document 中需要存在一个 body\");\r\n\r\n    // 生成 dom 元素\r\n    let input = document\r\n        .create_element(\"input\")?\r\n        .dyn_into::&#x3C;web_sys::HtmlInputElement>()?;\r\n    let btn = document.create_element(\"button\")?;\r\n    btn.set_text_content(Some(&#x26;\"点击计算斐波那契数\"));\r\n    let out = document.create_element(\"h3\")?;\r\n    let input = Rc::new(input); // 为了不违背“一个变量只能有一个所有者”的规则，需要使用 Rc 包裹 input 元素，方便在闭包中拿到并使用它的值\r\n    let out = Rc::new(RefCell::new(out)); // 因为需要改变 out 元素的 textContent，需要使用 RefCell 包裹方便去在闭包中把它当做可变变量来改变它\r\n    {\r\n        let out = out.clone(); // 复制一份智能指针\r\n        let input = input.clone();\r\n        // 使用到 wasm_bindgen::closure::Closure，它的作用是打通 Rust 中的闭包和 JS 中的闭包\r\n        let closure = Closure::&#x3C;dyn Fn()>::new(move || {\r\n            let val = input.value();\r\n            let num = val.parse::&#x3C;u32>().unwrap();\r\n            let res = fib(num);\r\n            out.borrow_mut()\r\n                .set_text_content(Some(res.to_string().as_str())); // 在这里使用 borrow_mut 把 out 当做可变变量获取出来，并设置 textContent\r\n        });\r\n\r\n        btn.add_event_listener_with_callback(\"click\", closure.as_ref().unchecked_ref())?; // 挂载事件监听器，将闭包函数先转换为 JS 值，再跳过类型判断，再作为回调函数传给 btn\r\n        closure.forget(); // 释放 Rust 对这片堆内存的管理，交给 JS 的 GC 去回收\r\n    }\r\n\r\n    body.append_child(&#x26;input)?;\r\n    body.append_child(&#x26;btn)?;\r\n    body.append_child(&#x26;out.borrow())?; // 挂载 DOM 元素节点\r\n    Ok(())\r\n}\n</code></pre>\n<p>上述 <code>init()</code> 添加了 <code>#[wasm_bindgen(start)]</code> 宏标注，<code>init()</code> 函数会在 WASM 模块初始化时自动执行。因此不再需要更改 <code>index.js</code> 文件。</p>\n<p>直接运行服务：</p>\n<pre><code>npm run serve\n</code></pre>\n<p>打开 <a href=\"http://localhost:8082/\">http://localhost:8082/</a> ，成功！</p>\n<p>打开检查，我们可以发现 <code>body</code> 上正确地挂载了 DOM 元素。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/055d7fc6faf443c298d98c1799f6842d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<h3>性能指标</h3>\n<p>我们先在 <code>lib.rs</code> 中加上以下代码，允许 Rust 代码中调用 <code>console.log</code> 。</p>\n<pre><code>#[wasm_bindgen]\r\nextern \"C\" {\r\n    #[wasm_bindgen(js_namespace = console)]\r\n    fn log(s: &#x26;str); // 将 js 命名空间中的 console.log 方法定义在 Rust 中\r\n}\r\n\r\n// 定义 console.log! 宏\r\nmacro_rules! console_log {\r\n    ($($t:tt)*) => (log(&#x26;format_args!($($t)*).to_string()))\r\n}\n</code></pre>\n<p>接着，在刚刚的求斐波那契数的应用中加上 <code>performance</code> API 相关的代码。</p>\n<p>在 <code>Cargo.toml</code> 中加上 Performance 的 features：</p>\n<pre><code>[dependencies.web-sys]\r\nversion = \"0.3.4\"\r\nfeatures = [\r\n  'Document',\r\n  'Element',\r\n  'HtmlElement',\r\n  'Node',\r\n  'Window',\r\n  'Performance', // 加上这一行\r\n  'HtmlInputElement'\r\n]\n</code></pre>\n<p>将求斐波那契数应用中的 <code>closure</code> 方法进行如下重写：</p>\n<pre><code>let closure = Closure::&#x3C;dyn Fn()>::new(move || {\r\n    let performance = window\r\n        .performance()\r\n        .expect(\"performance should be available\"); // 获取 window.performance\r\n\r\n    let val = input.value();\r\n    let num = val.parse::&#x3C;u32>().unwrap();\r\n    let start = performance.now(); // 调用 performance.now() 获取当前时间\r\n    console_log!(\"the start time (in ms) is {}\", start);\r\n    let res = fib(num);\r\n    let end = performance.now();\r\n    console_log!(\"the end time (in ms) is {}\", end);\r\n    console_log!(\"delta (in ms) is {}\", end-start);\r\n    out.borrow_mut()\r\n        .set_text_content(Some(res.to_string().as_str()));\r\n});\n</code></pre>\n<p>运行服务器：</p>\n<pre><code>npm run serve\n</code></pre>\n<p>现在在控制台就能够看到执行运算的耗时了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e5a10842de41929b2d101f2313c27b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<blockquote>\n<p>执行运算的<a href=\"https://recordit.co/muajFCjHAR\">录屏</a></p>\n</blockquote>\n<p>性能比较：</p>\n<table>\n<thead>\n<tr>\n<th>fib(n)</th>\n<th>10</th>\n<th>20</th>\n<th>30</th>\n<th>35</th>\n<th>40</th>\n<th>45</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wasm</td>\n<td>0.30</td>\n<td>0.90</td>\n<td>69.90</td>\n<td>726.59</td>\n<td>8018</td>\n<td>90918.79</td>\n</tr>\n<tr>\n<td>js</td>\n<td>0.19</td>\n<td>0.80</td>\n<td>67.70</td>\n<td>753.20</td>\n<td>8061</td>\n<td>91794.70</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，<em>在 n 不大的场景下，WASM 的耗时比纯 JS 还要长</em>，这是因为浏览器需要在 VM 容器中对 WASM 模块进行实例化，可能这一部分会消耗相当的时间，导致性能不如纯 JS 的执行。随着运算规模变大，WASM 的优化越来越明显。</p>\n<h2>总结</h2>\n<p>WASM 从 2017 年 3 月推出以来，已然成了 Web 开发的未来发展趋势之一。</p>\n<p>本文不仅介绍了 WASM 的背景、环境配置、Rust 项目初始化、编译和使用 WASM 等基本用法，还通过一个简单的应用介绍了 WASM 与 webpack 配合开发、与 DOM 之间交互以及性能指标分析等进阶用法。</p>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://rustwasm.github.io/docs/book/introduction.html\">Rust and WebAssembly</a></li>\n<li><a href=\"https://rustwasm.github.io/wasm-bindgen/examples/hello-world.html\">hello-world</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API\">Using the WebAssembly JavaScript API</a></li>\n<li><a href=\"https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html\">Closure in wasm_bindgen::closure - Rust (rustwasm.github.io)</a></li>\n<li><a href=\"https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html\">start - The <code>wasm-bindgen</code> Guide (rustwasm.github.io)</a></li>\n<li><a href=\"https://dev.to/yjdoc2/make-a-combined-library-and-binary-project-in-rust-d4f\">Make a Combined Library and Binary Project in Rust - DEV Community 👩‍💻👨‍💻</a></li>\n</ul>\n"}},"__N_SSG":true}