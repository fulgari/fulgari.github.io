{"pageProps":{"post":{"title":"ProxyHandler 用法","date":"2022-03-22","slug":"proxyhandler","content":"<h2>ProxyHandler</h2>\n<p>我们都知道 Proxy 能够捕获一些对对象的处理操作，并在这之上添加额外的逻辑。那么具体它是怎么使用的，本文将作简要介绍。</p>\n<p>点开 typescript/liv/lib.es2015.proxy.d.ts 能够找到 ProxyHandler 中的对应接口：</p>\n<pre><code>interface ProxyHandler&#x3C;T extends object> {\r\n    // 后面加小括号，函数调用时\r\n    apply?(target: T, thisArg: any, argArray: any[]): any;\r\n    // 使用 new 时，函数作为构造函数\r\n    construct?(target: T, argArray: any[], newTarget: Function): object;\r\n    // 使用 defineProperty 进行属性定义时\r\n    // 对对象的访问器属性（没有 value，只能通过 defineProperty 定义的属性）或数值属性（value,enumerable,configurabble,writable）\r\n    defineProperty?(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean;\r\n    // 使用 delete 删除对象属性\r\n    deleteProperty?(target: T, p: string | symbol): boolean;\r\n    // 访问对象的值时，xxx = 对象 或 对象.xxx\r\n    get?(target: T, p: string | symbol, receiver: any): any;\r\n    // 使用 Object.getOwnPropertyDescriptor 获取对象上某个属性的 descriptor 描述符（比如是否 configurable 等）\r\n    getOwnPropertyDescriptor?(target: T, p: string | symbol): PropertyDescriptor | undefined;\r\n    // 使用 Object.getPrototypeOf 获取原型时\r\n    getPrototypeOf?(target: T): object | null;\r\n    // 使用 in 判断是否含有某属性时\r\n    has?(target: T, p: string | symbol): boolean;\r\n    // 使用 Object.isExtensible 判断对象能否添加新属性时\r\n    isExtensible?(target: T): boolean;\r\n    // 获取对象的 keys 键值相关操作 如Object.getOwnPropertyNames()，Object.getOwnPropertySymbols()，Object.keys()\r\n    ownKeys?(target: T): ArrayLike&#x3C;string | symbol>;\r\n    // 使用 Object.preventExtensions 禁止新增属性时\r\n    preventExtensions?(target: T): boolean;\r\n    // 对象 = xx，给对象设置新值时\r\n    set?(target: T, p: string | symbol, value: any, receiver: any): boolean;\r\n    // 使用 Object.setPrototypeOf() 给对象设置原型时\r\n    setPrototypeOf?(target: T, v: object | null): boolean;\r\n}\n</code></pre>\n<blockquote>\n<p>上述 Proxy 的 handler 即处理函数，也叫做“陷阱”（trap），因为它们捕获对底层目标对象的调用。\r\n其实玩过富文本编辑器框架 slate.js，就知道其插件系统中如 insertText/insertNode/deleteBackward/apply 等，也是一个陷阱。\r\n我们可以在陷阱中对插件系统的默认行为进行一层拦截。</p>\n</blockquote>\n<pre><code>const a = function() {}\r\n\r\nconst p = new Proxy(a, {\r\n  apply: (args) => {\r\n    console.log(\"APPLY\")\r\n    return Reflect.apply(Object, args)\r\n  }\r\n})\r\n\r\np()\n</code></pre>\n<p>以上是一个简单的 Proxy 使用示例。</p>\n<p>其中</p>\n<ul>\n<li>ProxyHandler 是 <code>apply</code>，在每次函数调用的时候都被触发；</li>\n<li>Reflect 是反射函数，能够保留原始的 <code>Object.apply</code> 用法（等同于保底的一个处理方案）。</li>\n</ul>\n"}},"__N_SSG":true}